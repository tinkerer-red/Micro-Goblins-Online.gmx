<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_camera</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init / allow use of views, and set zooms

resizing = false;
is_fullscreened = false;
free_cam_mode = false

//set the ideal resolution
ideal_h = 288;
ideal_w = 512;
ideal_volume = ideal_h+ideal_w;
max_view_radius = (fast_hype(obj_camera_control.ideal_h*2, obj_camera_control.ideal_w*2) * 1.1) /2
    
split_boarder = 2

hh_remainder = false

ww = 0;
hh = 0;

if !view_enabled{
  view_enabled = true;
}
    
for (var i = 0; i &lt; 8; i++)
{
  player_zoom[i] = 1
  res_scale[i] = 1
  view_visible[i] = false
  view_surface[i] = -1
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Allow for sub pixel movement

upscale_val = 1
smooth_camera = false


if (smooth_camera){
  upscale_val = 2
  //texture_set_interpolation(true);
  surface_resize(application_surface,window_get_width()*upscale_val,window_get_height()*upscale_val)

}else{
  texture_set_interpolation(false);
}

///rescale the GUI
display_set_gui_size(window_get_width(),window_get_height());
texture_set_interpolation(false);



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init frameskip variables

max_frame_skip = 4 //10 at 60fps 3 at 20 fps
frames_skipped = 0

frame_rate = 60
frame_counter = 0
frame_delay = 0
//frame_mod = 1
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Window's frame manipulation (Windows Only)

window_frame_was_ready = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// [debug] resolution 

for (var i = 0; i &lt; global.numberOfLocalPlayers; i++)
{
  var ideal_h = 288;
  var ideal_w = 512;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Zoom



if (global.numberOfLocalPlayers = 1)
{
  //singleplayer zoom funstions
  if (obj_controller.zoom_in_pressed[0]) || (obj_controller.zoom_out_pressed[0]) || resizing
  {
    if (obj_controller.zoom_in_pressed[0] = true)
      {player_zoom[0] = player_zoom[0] * 2};
    if (obj_controller.zoom_out_pressed[0] = true)
      {player_zoom[0] = player_zoom[0] / 2};
    
    //player_zoom[0] = clamp(player_zoom[0], 0.125, 8)
    if (global.debug = false){
      player_zoom[0] = clamp(player_zoom[0], 0.5, 2)
    }else{
      player_zoom[0] = clamp(player_zoom[0], 0.0078125, 32)
    }
    
    view_hview[0] = view_hport[0]/(player_zoom[0]*res_scale[0])
    view_wview[0] = view_wport[0]/(player_zoom[0]*res_scale[0])
    
    view_xview[0] = view_object[0].x - view_wview[0]/2
    view_yview[0] = view_object[0].y - view_hview[0]/2
    
    view_hborder[0] = 0 //view_wview[0]/2
    view_vborder[0] = 0 //view_hview[0]/2
  }
}
else
{
  //multiplayer zoom functions
  
  var top_split    = floor(global.numberOfLocalPlayers/2)
  var bottom_split = ceil(global.numberOfLocalPlayers/2)
  
  var view_port_height = hh/2
  
  for (var i = 0; i &lt; global.numberOfLocalPlayers; i++)
  {
    if (obj_controller.zoom_in_pressed[0] = true)
      {player_zoom[i] = player_zoom[i] * 2};
    if (obj_controller.zoom_out_pressed[0] = true)
      {player_zoom[i] -= player_zoom[i] / 2};
       
    //player_zoom[i] = clamp(player_zoom[i], 0.125, 8)
    if (global.debug = false){
      player_zoom[i] = clamp(player_zoom[i], 0.5, 2)
    }else{
      player_zoom[i] = clamp(player_zoom[i], 0.0078125, 8)
    }
    
    if (obj_controller.zoom_in_pressed[0]) || (obj_controller.zoom_out_pressed[0]) || resizing{
      view_hview[i] = view_hport[i]/(player_zoom[i]*res_scale[i])
      view_wview[i] = view_wport[i]/(player_zoom[i]*res_scale[i])
      
      view_xview[i] = view_object[i].x - view_wview[i]/2
      view_yview[i] = view_object[i].y - view_hview[i]/2
    }
  }
}

//}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Move views for movement

for (var i = 0; i &lt; global.numberOfLocalPlayers; i++){
  with view_object[i]{
    if !is_interior(x,y)
    {
      ideal_x = x //+ clamp(lengthdir_x((view_wview[i]*0.25)*(self.spd/2), self.dir),-(view_wview[i]*0.25),view_wview[i]*0.25)
      ideal_y = y //+ clamp(lengthdir_y((view_hview[i]*0.25)*(self.spd/2), self.dir),-(view_hview[i]*0.25),view_hview[i]*0.25)
      
      view_xview[i] = ideal_x-view_wview[i]/2
      view_yview[i] = ideal_y-view_hview[i]/2
      
      if (!obj_camera_control.free_cam_mode) &amp;&amp; (variable_global_exists("chunk_handler"))
      {
        view_xview[i] = clamp(view_xview[i], 0,  global.chunk_handler.world_width-view_wview[i])
        view_yview[i] = clamp(view_yview[i], 0,  global.chunk_handler.world_height-view_hview[i])
      }
    
    
    }else{//if the player is inside an interior cell
      ideal_x = x //+ clamp(lengthdir_x((view_wview[i]*0.25)*(self.spd/2), self.dir),-(view_wview[i]*0.25),view_wview[i]*0.25)
      ideal_y = y //+ clamp(lengthdir_y((view_hview[i]*0.25)*(self.spd/2), self.dir),-(view_hview[i]*0.25),view_hview[i]*0.25)
      
      view_xview[i] = ideal_x-view_wview[i]/2
      view_yview[i] = ideal_y-view_hview[i]/2
      
      if (!obj_camera_control.free_cam_mode)
      {
        //find the chunks
        var array = xy_to_chunk(x,y);
        var chunk_x = array[0]
        var chunk_y = array[1]
        
        //find the interior map and grid pos
        var array = interior_chunk_find_grid_pos(chunk_x, chunk_y);
        if (array = undefined){
            continue;
          }
        grid_x = array[0];
        grid_y = array[1];
        map = array[2];
        
        //find the bounding limits
        var array = interior_rooms_connected_to_bbox(map, grid_x, grid_y);
        var tile_size = global.chunk_handler.tile_size
        
        bbox_view_up    = array[0]-tile_size
        bbox_view_down  = array[1]+tile_size
        bbox_view_left  = array[2]-tile_size
        bbox_view_right = array[3]+tile_size
        
        //possition x
        if (view_wview[i] &gt; (bbox_view_right - bbox_view_left)){
          var ideal_x = bbox_view_left + (bbox_view_right-bbox_view_left)/2;
          view_xview[i] = ideal_x-view_wview[i]/2
        }else{
          ideal_x = x //+ clamp(lengthdir_x((view_wview[i]*0.25)*(self.spd/2), self.dir),-(view_wview[i]*0.25),view_wview[i]*0.25)
          view_xview[i] = ideal_x-view_wview[i]/2
          view_xview[i] = clamp(view_xview[i], bbox_view_left, bbox_view_right-view_wview[i])
        }
        
        //possition y
        if (view_hview[i] &gt; (bbox_view_down - bbox_view_up)){
          var ideal_y = bbox_view_up + (bbox_view_down-bbox_view_up)/2;
          view_yview[i] = ideal_y-view_hview[i]/2
        }else{
          ideal_y = y //+ clamp(lengthdir_x((view_wview[i]*0.25)*(self.spd/2), self.dir),-(view_wview[i]*0.25),view_wview[i]*0.25)
          view_yview[i] = ideal_y-view_hview[i]/2
          view_yview[i] = clamp(view_yview[i], bbox_view_up, bbox_view_down-view_hview[i])
        }
        
      }
    }
  }
}




































</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///handle frame skipping
if !resizing{
  
  var frame_mod = room_speed/frame_rate;
  
  var last_frame_counter = frame_counter;
  frame_counter = frame_counter mod frame_mod
  
  if (last_frame_counter != frame_counter)
  {var frame_over = true} else {var frame_over = false;}
  
  if (frame_over = false)
  || ((lag() &gt; 2) &amp;&amp; (frames_skipped &lt; max_frame_skip))
  {
    draw_enable_drawevent(false);
    
    frames_skipped++
    
  }else{
    draw_enable_drawevent(true);
    draw_clear(c_black);
    
    frames_skipped = 0;
  }
  
  
  frame_counter += 1*lag();
  
  //this variable is used when any script inside the draw event needs to know how many frames of animation it needs to skip to make the animations take equally as long for all settings. Very important
  frame_delay += 1*lag();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///[Non Windows OS] resize the app surface

if true //(os_type != os_windows)
{
  //check for resize
  if
  (
    (surface_get_width(application_surface) != floor(ww)) || (surface_get_height(application_surface) != floor(hh))
    || ((smooth_camera &amp;&amp; ((surface_get_width(application_surface) != floor(display_get_gui_width()*upscale_val)) || (surface_get_height(application_surface) != floor(display_get_gui_height()*upscale_val))))
    || (!smooth_camera &amp;&amp; ((surface_get_width(application_surface) != display_get_gui_width()) || (surface_get_height(application_surface) != display_get_gui_height()))))
  )
  &amp;&amp; !window_minimized() 
  {
    if (smooth_camera){
      if !is_fullscreened{
        ww = display_get_gui_width()*upscale_val;
        hh = display_get_gui_height()*upscale_val;
      }else{
        ww = display_get_width()*upscale_val;
        hh = display_get_height()*upscale_val;
      }
    }else{
      if !is_fullscreened{
        ww = display_get_gui_width();
        hh = display_get_gui_height();
      }else{
        ww = display_get_width();
        hh = display_get_height();
      }
    }
    
    if (ww != 0) &amp;&amp; (hh != 0){
      surface_resize(application_surface, ww, hh)
    }
    
    
    ///define number of player screens per row
    if (global.numberOfLocalPlayers = 1){
      with obj_player{
        if (htme_isLocal()){
          if (player_id_local = 0){
            view_object[0] = self
            
          }
        }
      }
      view_hspeed[0] = 0
      view_vspeed[0] = 0
      
      view_hport[0] = hh
      view_wport[0] = ww
      
      view_visible[0] = true
    }
    else
    {
      var top_split    = floor(global.numberOfLocalPlayers/2)
      var bottom_split = ceil(global.numberOfLocalPlayers/2)
      
      var view_port_height = hh/2
      
      for (var i = 0; i &lt; global.numberOfLocalPlayers; i++){
        with obj_player{
          if (htme_isLocal()){
            if (player_id_local = i){
              view_object[i] = self
            }
          }
        }
        view_hspeed[i] = 0
        view_vspeed[i] = 0
        
        //resize the width and height of each view
        
        if (i &lt; top_split)
        {
            view_wport[i] = ww/top_split
            view_xport[i] = (ww/top_split)*(i) 
            view_yport[i] = 0
            view_hport[i] = ceil(view_port_height)
        } else {
          view_wport[i] = ww/bottom_split
          view_xport[i] = (ww/bottom_split)*(i-top_split) 
          view_yport[i] = ceil(view_port_height)
          view_hport[i] = floor(view_port_height)
        }
        
        view_hborder[i] = 0
        view_vborder[i] = 0
        
        view_visible[i] = true
      }
      
      
    }
    
    
    
    
    ///resolution scaling variable set
    if (global.numberOfLocalPlayers = 1)
    {
      var v_res = hh;
      var h_res = ww;
      res_volume = v_res+h_res;
      
      res_scale[0] = res_volume/ideal_volume;
      
      view_hview[0] = view_hport[0]/(player_zoom[0]*res_scale[0])
      view_wview[0] = view_wport[0]/(player_zoom[0]*res_scale[0])
      
      view_xview[0] = view_object[0].x - view_wview[0]/2
      view_yview[0] = view_object[0].y - view_hview[0]/2
      
    }else{
      for (var i = 0; i &lt; global.numberOfLocalPlayers; i++)
      {
        var v_res = view_hport[i];
        var h_res = view_wport[i];
        res_volume = v_res+h_res;
        
        res_scale[i] = (res_volume/2)/(ideal_volume/2);
        
        view_hview[i] = view_hport[i]/(player_zoom[i]*res_scale[i])
        view_wview[i] = view_wport[i]/(player_zoom[i]*res_scale[i])
        
        view_xview[i] = view_object[i].x - view_wview[i]/2
        view_yview[i] = view_object[i].y - view_hview[i]/2
        
      }
    }
    
    
    
    
  }

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>


if (smooth_camera)
&amp;&amp; ((os_type = os_windows &amp;&amp; window_frame_has_focus()))
&amp;&amp; !window_minimized() 
{
  surface_resize(application_surface,window_get_width()*upscale_val,window_get_height()*upscale_val)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw debug bounding box

/*
draw_line(1,1,window_get_width()-1, window_get_height()-1)
draw_line(1,1,window_get_width()-1, 1)
draw_line(window_get_width()-1, 1,window_get_width()-1, window_get_height()-1)
draw_line(window_get_width()-1, window_get_height()-1,1, window_get_height()-1)
draw_line(1,1,1, window_get_height()-1)

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///reset frameskip delay counter

//this variable is used when any script inside the draw event needs to know how many frames of animation it needs to skip to make the animations take equally as long for all settings. Very important
frame_delay = 0
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="74">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///rescale the GUI
display_set_gui_size(window_get_width(),window_get_height());
texture_set_interpolation(false);



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw screen seporators

if (global.numberOfLocalPlayers != 1)
{
  var top_split    = floor(global.numberOfLocalPlayers/2)
  //var bottom_split = ceil(global.numberOfLocalPlayers/2)
  
  var view_port_height = hh/2
  
  var line_width = 3
  
  for (var i = 0; i &lt; global.numberOfLocalPlayers; i++)
  {
    draw_set_color(c_white)
    if (i != top_split) &amp;&amp; (i != 0){
      //left line
      draw_line_width(view_xport[i], view_yport[i]-1, view_xport[i], view_yport[i]+view_hport[i]+1, line_width)
    }
    if (i &lt; top_split){
      //bottom line
      draw_line_width(view_xport[i]-1, view_yport[i]+view_hport[i], view_xport[i]+view_wport[i]+1, view_yport[i]+view_hport[i], line_width)
    }
  }
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///stretch draw the application surface

if (smooth_camera || resizing)
&amp;&amp; !window_minimized() 
{
  // DISABLE ALPHABLEND BECAUSE SURFACES //
  draw_enable_alphablend(0);
  texture_set_interpolation(true);
  
  // GET OFFSET OF THE APPLICATION SURFACE FOR MANUAL DRAWING //
  var offset = application_get_position();
  
  //resize our application surface
  //surface_resize(application_surface,window_get_width(),window_get_height())
  
  // RESET ALPHABLEND //
  draw_enable_alphablend(1);
  //texture_set_interpolation(false);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///dont draw self
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
