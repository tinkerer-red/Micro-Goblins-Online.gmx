<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init inventory

//we initialize this variable as false because we check to see if its an array in the step event
menu_background_surface = false;
update_menus = true

//build an enum for handling the item keys for the equipment slots
enum equip{
  head,
  body,
  boggle,
  item_a,
  item_b,
  item_c
}

enum sub_menu{
  equip,
  unequip,
  consume,
  combine,
  drop,
}

//prep the init
init_menu = true
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///reset the button press buffers

for (player_i = 0; player_i &lt;= global.numberOfLocalPlayers; player_i++){
  selected_this_frame[player_i] = false
  backed_this_frame[player_i] = false
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init the menu

if (init_menu){
  
  init_menu = false;
  
  //for every player
  var player_i
  for (player_i = 0; player_i &lt;= 8; player_i++)
  {
    //first we need to find out if the player has loaded a save file.
    var player_had_loaded = false;
    
    
    //load the inventory of the player
    with (obj_player){
      if (player_id_local = player_i){
        var _nbt = nbt;
        other.menu_player_id[player_i] = id
      }
    }
    
    nbt_data[player_i] = _nbt
    
    //menu
    prev_inv_items_per_row[player_i] = 0
    inv_items_per_row[player_i] = 0
    max_items[player_i] = 20
    menu_open[player_i] = 0
    cursor_pos[player_i] = 5
    tab_pos[player_i] = 0
    
    //sub menu
    sub_menu_cursor_pos[player_i] = 0
    in_sub_menu[player_i] = 0
    selected_item_map[player_i] = noone
    sub_menu_spawned[player_i] = false
    sub_menu_anim_finished[player_i] = false
    
    //surfaces
    menu_background_surface[player_i] = noone
    menu_inventory_surface[player_i] = noone
    sub_menu_surface[player_i] = noone
    sub_menu_options[player_i] = noone
    sub_menu_is_equiping[player_i] = false
    sub_menu_is_combining[player_i] = false
    sub_menu_event_inv_cursor_pos[player_i] = 5
    
    //lore
    lore_surface[player_i] = noone
    
    //add a buffer to prevent pressing select once and accidently clicking 3 selects in a row
    selected_this_frame[player_i] = false;
    backed_this_frame[player_i] = false;
    
  }
    

  
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Rescale the menus



//for every player
for (player_i = 0; player_i &lt; global.numberOfLocalPlayers; player_i++)
{

  if (window_resized()
  || obj_camera_control.updated_resolution
  || !surface_exists(menu_background_surface[player_i]))
  || update_menus
  {
    
    if (update_menus){
      surface_free(menu_background_surface[player_i])
      surface_free(menu_inventory_surface[player_i])
      surface_free(sub_menu_surface[player_i])
      surface_free(lore_surface[player_i])
    }
    
    draw_set_alpha(1)
    draw_set_color(c_white)
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    
    //text transphormer
    var text_scaling = 0.5
    
    if (obj_camera_control.smooth_camera){
     var res_scale = 1/obj_camera_control.upscale_val
    }else{
      var res_scale = 1
    }
  
  
    
    
    //most importantly we will need to load the NBT data of the player to get their inventory information!
    var nbt = nbt_data[player_i];
    
    
    
    //get the coords of the view, width and height
    v_x[player_i] = view_xport[player_i]
    v_y[player_i] = view_yport[player_i]
    v_w[player_i] = view_wport[player_i]
    v_h[player_i] = view_hport[player_i]
    
    //grab the size of the art boarder, in the future this might make a difference with unique art styles in the settings
    var art_border = sprite_get_height(spr_menu_9slice) / 3;
    
    //grab the volume of the screen size
    //determine the scaling in which to use, assuming we dont have the value set in the settings
    
    /////find the scale in which to use (unless the player has specified the ui scale to use)
    var ideal_width = 188
    var ideal_height = 240
    var scale1 = v_w[player_i] div ideal_width;
    var scale2 = v_h[player_i] div ideal_height;
    gui_scale[player_i] = floor(min(scale1, scale2));
    
    if (gui_scale[player_i] &lt; 1) {
      //setting this to 0.5 actually causes the original surface to end up being 2x the standard size, but oh well
      gui_scale[player_i] = 0.5
    }
    
    var _gui_scale = gui_scale[player_i];
    
    //once we know the scale, lets reset the view height to fix some scaling issues
    v_w[player_i] = floor(v_w[player_i]/gui_scale[player_i])
    v_h[player_i] = floor(v_h[player_i]/gui_scale[player_i])
    
    
    //calculate the space which will actually be viable,
    
    //find the tab sizes
    tab_height[player_i] = sprite_get_height(spr_menu_tab_icons);
    tab_width[player_i] = sprite_get_width(spr_menu_tab_icons);
    
    //remove the art boarder from total sizes
    menu_width[player_i] = v_w[player_i] - 8;
    menu_height[player_i] = v_h[player_i] - art_border - art_border - tab_height[player_i];
    
    //find the info box size
    info_section_width[player_i] = (16+art_border+art_border)*3 //3 sprite sizes + 2 borders on each side, 3*16 + 4*2*3
    
    //find the scrollbar size
    scroll_bar_width[player_i] = (2+art_border+art_border) //2 pixels for the bar it's self and 4 pixels on each side for the art
    
    //inventory size
    inv_width[player_i] = menu_width[player_i] - info_section_width[player_i] - scroll_bar_width[player_i];
    inv_height[player_i] = menu_height[player_i];
    
    //draw the inventory box (temporary untill we know the calculations are correct)
    var x1 = art_border+info_section_width[player_i];
    var y1 = art_border + tab_height[player_i];
    var x2 = v_w[player_i]-scroll_bar_width[player_i]-art_border;
    var y2 = v_h[player_i]-(art_border);
    
    //store the previous items per row so we know if we need to update the inventory grid
    prev_inv_items_per_row[player_i] = inv_items_per_row[player_i]
    
    inv_items_per_row[player_i] = min((x2-x1) div 34, 6)
    inv_width[player_i]       = inv_items_per_row[player_i]*34;
    inv_height[player_i]      = y2-y1;
    
    inventory_x_off[player_i] = x1+2;
    inventory_y_off[player_i] = y1;
    
    
    
    var surface_width = info_section_width[player_i] + art_border*2 + inv_width[player_i] +scroll_bar_width[player_i] +2;
    
    //once we have all the relevant information lets create a surfaces so we dont have to draw all of this every frame
    menu_background_surface[player_i] = surface_create(surface_width, v_h[player_i]);
    
    
  //this leaves us only to draw on the surfaces,
    //for the background surface draw all the static objects which are unchanging
    surface_set_target(menu_background_surface[player_i])
    
    
    //first we need to draw the tabs since they are furthest in the back
    var icon_width = sprite_get_width(spr_menu_tab_icons)
    var icon_height = sprite_get_height(spr_menu_tab_icons)
    var tab_count = 6
    var x_offset = (surface_width-icon_width*tab_count)/2
    for(var icon_index = 0; icon_index &lt; tab_count; icon_index++){
      var x1 = x_offset+(icon_width*icon_index)
      var y1 = 0
      
      draw_sprite_ext(spr_menu_tab_icons, icon_index, x1, y1, 1, 1, 0, c_white, 1)
    }
    
    
    
    //now draw the entire background of the menu
    scr_draw_9slices_ext(spr_menu_9slice, 0, 0, icon_height, surface_width, v_h[player_i], c_white, 1, 1)
    
    
    
    //now draw the 6 equipment slots
    var x_off = art_border;
    var y_off = icon_height + art_border;
    for(var equip_y = 0; equip_y &lt; 2; equip_y++)     for(var equip_x = 0; equip_x &lt; 3; equip_x++) {
      var x1 = x_off+ ((16+art_border+art_border)*equip_x)
      var y1 = y_off+ ((16+art_border+art_border)*equip_y) 
      var x2 = x1 + (16+art_border+art_border)
      var y2 = y1 + (16+art_border+art_border)
      
      //draw the inventory slot for the item
      scr_draw_9slices_ext(spr_menu_9slice, 0, x1, y1, x2, y2, c_white, 1, 1)
      
      switch (equip_x+(equip_y*3)){
        case equip.head:   var item_key = "armor_head";   break;
        case equip.body:   var item_key = "armor_body";   break;
        case equip.boggle: var item_key = "armor_boggle"; break;
        case equip.item_a: var item_key = "held_item_a";  break;
        case equip.item_b: var item_key = "held_item_b";  break;
        case equip.item_c: var item_key = "held_item_c";  break;
        default:           var item_key = "";             break; //this is only here to prevent reading from a bad section of ram
      }
      
      //draw the item
      draw_item(nbt[? item_key], x1+art_border, y1+art_border, 16, 16)
      //show_debug_message("nbt[? "+item_key+"] = "+json_encode(nbt[? item_key]))
    }
    
    
    //draw the text box for lore and modifiers
    var x1 = x_off;
    var y1 = y2+1+info_section_width[player_i]+1;
    var x2 = x1+info_section_width[player_i];
    var y2 = v_h[player_i]-art_border;
    
    sub_menu_x[player_i] = x1*_gui_scale;
    sub_menu_y[player_i] = y1*_gui_scale;
    sub_menu_w[player_i] = (x2-x1)*_gui_scale;
    sub_menu_h[player_i] = (y2-y1)*_gui_scale;
    //scr_draw_9slices_ext(spr_menu_9slice, 0, x1, y1, x2, y2, c_white, 1, 1)
    
    
    lore_x[player_i] = inventory_x_off[player_i]*_gui_scale;
    lore_y[player_i] = sub_menu_y[player_i];
    lore_w[player_i] = inv_width[player_i]*_gui_scale;
    lore_h[player_i] = sub_menu_h[player_i];
    
    
    //draw the scroll bars boarder
    var x2 = surface_width-art_border;
    var y2 = v_h[player_i]-art_border;
    var x1 = x2 - scroll_bar_width[player_i];
    var y1 = art_border + icon_height;
    scr_draw_9slices_ext(spr_menu_9slice, 0, x1, y1, x2, y2, c_white, 1, 1)
    
    
    //draw the bounding box for the inventory for debugging purposes
    /*
    scr_draw_9slices_ext(spr_menu_9slice,
                         0, 
                         inventory_x_off[player_i], 
                         inventory_y_off[player_i], 
                         inventory_x_off[player_i]+inv_width[player_i], 
                         inventory_y_off[player_i]+inv_height[player_i], 
                         c_white, 
                         1, 
                         1)
    */
    
    
    //once we're done drawing reset the surface target
    surface_reset_target()
    
    
    
    
    
    
    
    
    //for the inventory, sort all the items into a grid, then cycle through them all drawing the required items, of course the surface only needs the data that it can see, no reason to draw items which arent going to show up since a player could be dropping items before they are even seen. This should be its own function to prevent to many draw calls each frame and anytime something is dropped we can update it all with the same script.
    
    max_items[player_i] = nbt[? "max_inventory_slots"];
    var height = ceil(max_items[player_i]/inv_items_per_row[player_i])*34;
    
    //using the left over variables we made lets create the surface
    menu_inventory_surface[player_i] = surface_create(inv_width[player_i], height);
    
    surface_set_target(menu_inventory_surface[player_i])
    
    
    
    
    //now lets populate that checkerboard with the items
    
      
    //first check to see if the items per row has even changed,
    //  if it hasn't then there is no reason to update the surface
//    if (prev_inv_items_per_row[player_i] != inv_items_per_row[player_i])
//    || (max_items[player_i] != nbt[? "max_inventory_slots"]){
      
        var max_y = ceil(max_items[player_i]/inv_items_per_row[player_i]);
        var item_counter = 0;
        var inventory_list = nbt[? "inventory"]
        
        var is_finished = false;
        
        for (var yy = 0; yy &lt; max_y; yy++){
          for (var xx = 0; xx &lt; inv_items_per_row[player_i]; xx++){
            
            var x1 = xx*34;
            var y1 = yy*34;
            
            //draw the inventory slots which are open
            draw_sprite(spr_menu_inventory_slot, 0, x1, y1)
            
            //draw the sprite of the item, with the correct hue
            draw_item(inventory_list[| item_counter], x1+1, y1+1, 32, 32)
            
            //acount for how many items we cycled through, then break when we reached the max
            item_counter++
            if (item_counter = max_items[player_i]) {
              is_finished = true;
              break;
            }
          }
          if (is_finished) break;
        }
      
//      }
    
    
    surface_reset_target()
  }
    
    
    
}




/// reset the menu update
update_menus = false













</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///handle cursor movement

for (player_i = 0; player_i &lt;= 8; player_i++)
{
  if (menu_open[player_i]){
    if (!in_sub_menu[player_i])
    || (sub_menu_is_equiping[player_i] || sub_menu_is_combining[player_i]){
      
      //set the cursor location that we're going to be handling
      if (sub_menu_is_equiping[player_i] || sub_menu_is_combining[player_i]){
        var cursor_loc = sub_menu_event_inv_cursor_pos[player_i]
      }else{
        var cursor_loc = cursor_pos[player_i]
      }
      
      //handle the curser movement for the equipment slots
      if (cursor_loc &lt; 6){
        //up
        if (obj_controller.up_pressed[player_i] != 0)
        || (obj_controller.up_held[player_i] != 0)
        {
          if (cursor_loc &gt; 2){
            cursor_loc += -3
          }
        }
        //down
        if (obj_controller.down_pressed[player_i] != 0)
        || (obj_controller.down_held[player_i] != 0)
        {
          if (cursor_loc &lt; 3){
            cursor_loc += 3
          }
        }
        //left
        if (obj_controller.left_pressed[player_i] != 0)
        || (obj_controller.left_held[player_i] != 0)
        {
          //prevent the cursor from cycling to the top right, when on the bottom left
          if (cursor_loc != 3)
          &amp;&amp; (cursor_loc != 0){
            cursor_loc += -1
          }
        }
        //right
        if (obj_controller.right_pressed[player_i] != 0)
        || (obj_controller.right_held[player_i] != 0)
        {
          if (cursor_loc != 2){
            //if it's the second inventory row, go ahead and snap it to the second inv row pos
            if (cursor_loc = 5){
              cursor_loc = 6 + inv_items_per_row[player_i]
            }else{
              cursor_loc += 1
            }
          }else{
            cursor_loc = 6
          }
        }
        
        
      
      }else{
        //if we're in the inventory grid
        
        //up
        if (obj_controller.up_pressed[player_i] != 0)
        || (obj_controller.up_held[player_i] != 0)
        {
          //prevent pressing up on the top row
          if ((cursor_loc-6) div inv_items_per_row[player_i] &gt; 0){
            cursor_loc += -inv_items_per_row[player_i]
          }
        }
        //down
        if (obj_controller.down_pressed[player_i] != 0)
        || (obj_controller.down_held[player_i] != 0)
        {
          cursor_loc += inv_items_per_row[player_i]
          cursor_loc = clamp(cursor_loc, 0, max_items[player_i]+6-1)
        }
        //left
        if (obj_controller.left_pressed[player_i] != 0)
        || (obj_controller.left_held[player_i] != 0)
        {
          //prevent going left
          if ((cursor_loc-6) mod inv_items_per_row[player_i] &gt; 0){
            cursor_loc += -1
          }else{
          //if we are all the way left, then jump to the correct possition
            if ((cursor_loc-6) div inv_items_per_row[player_i] = 0){
            //if were on the first row go to the first equipment's row
              cursor_loc = 2
            }else{
            //else second row
              cursor_loc = 5
            }
          }
        }
        //right
        if (obj_controller.right_pressed[player_i] != 0)
        || (obj_controller.right_held[player_i] != 0)
        {
            //prevent going over the inventory size
          if (cursor_loc &lt; max_items[player_i]+6-1)
            //prevent cycling back to the left from the right
          &amp;&amp; ((cursor_loc-6) mod inv_items_per_row[player_i] != inv_items_per_row[player_i]-1)
          {
            cursor_loc += 1
          }
          
          
          
        }
        
      }
      
      //now apply the new position to the correct cursor pos
      if (sub_menu_is_equiping[player_i] || sub_menu_is_combining[player_i]){
        //if the selected item is an armor, only let it equip to that armor slot
        var item = selected_item_map[player_i];
        var item_type = item[? "item_type"]
        
        switch item_type
        {
          case item_type_armor_head:
            sub_menu_event_inv_cursor_pos[player_i] = equip.head
          break;
          case item_type_armor_body:
            sub_menu_event_inv_cursor_pos[player_i] = equip.body
          break;
          case item_type_armor_boggle:
            sub_menu_event_inv_cursor_pos[player_i] = equip.boggle
          break;
        }
        
        if (item_type = item_type_weapon_melee)
        || (item_type = item_type_weapon_range)
        || (item_type = item_type_weapon_summon)
        || (item_is_consumable(item)){
          sub_menu_event_inv_cursor_pos[player_i] = clamp(cursor_loc, 3, 5)
        }
      }else{
        cursor_pos[player_i] = cursor_loc
      }
      
      
      
      
      
    } //end of !sub_menu check
    
  }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///open and close the menu

for (player_i = 0; player_i &lt;= 8; player_i++)
{
  if (menu_open[player_i]){
    if (!in_sub_menu[player_i]){
      if (obj_controller.menu_back_pressed[player_i])
      &amp;&amp; (backed_this_frame[player_i] = false){
        backed_this_frame[player_i] = true
        menu_open[player_i] = false
      }
    }
  
  }else{ //if the menu isnt open
    if (obj_controller.menu_open_pressed[player_i]){
      menu_open[player_i] = true
      
      //also, incase the player's select button is the same thing as the open menu button add it to the buffer
      if (obj_controller.menu_select_pressed[player_i] != 0){
        selected_this_frame[player_i] = true;
      }
    }
  }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///sub menu and text box handling

for (player_i = 0; player_i &lt;= global.numberOfLocalPlayers; player_i++){
  if (menu_open[player_i]){
    
    draw_set_alpha(1)
    draw_set_color(c_white)
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);

    if (selected_item_map[player_i] = noone)
    &amp;&amp; (in_sub_menu[player_i] = false)
    {
      if (obj_controller.menu_select_pressed[player_i] != 0)
      &amp;&amp; (selected_this_frame[player_i] = false)
      {
        selected_this_frame[player_i] = true;
        var nbt = nbt_data[player_i]
        
        if (cursor_pos[player_i] &lt; 6){
          switch (cursor_pos[player_i]){
            case equip.head:   var item_key = "armor_head";   break;
            case equip.body:   var item_key = "armor_body";   break;
            case equip.boggle: var item_key = "armor_boggle"; break;
            case equip.item_a: var item_key = "held_item_a";  break;
            case equip.item_b: var item_key = "held_item_b";  break;
            case equip.item_c: var item_key = "held_item_c";  break;
            default:           var item_key = "";             break; //this is only here to prevent reading from a bad section of ram
          }
          
          //now remove the item and select it
          if ds_map_exists(nbt, item_key){
            selected_item_map[player_i] = nbt[? item_key]
            if ds_exists(selected_item_map[player_i], ds_type_map){
              in_sub_menu[player_i] = true
            }else{
              selected_item_map[player_i] = noone
            }
          }
          
        }else{ //if it's inside the inventory list
          var inventory_list = nbt[? "inventory"];
          var inv_loc = cursor_pos[player_i]-6;
          
          if (inv_loc &lt; ds_list_size(inventory_list)){
            selected_item_map[player_i] = inventory_list[| inv_loc]
            show_debug_message(json_encode(selected_item_map[player_i]))
            if ds_exists(selected_item_map[player_i], ds_type_map){
              in_sub_menu[player_i] = true
            }else{
              selected_item_map[player_i] = noone
            }
          }
          
        }
        
        
      }
    }
    
    
    
    
    //if an item has been selected
    if (selected_item_map[player_i] != noone)
    &amp;&amp; in_sub_menu[player_i]{
      
      //check to see if the sub menu was just spawned
      if (sub_menu_spawned[player_i] = false){
        sub_menu_spawned[player_i] = true
        //reset the anim frame incase an animation was playing while thew player selected a different item
        sub_menu_anim_frame[player_i] = 0
        
        
        //adjust the sub menu's options to prevnt consuming an armor or weapon
        sub_menu_options[player_i] = ds_list_create()
        var item = selected_item_map[player_i];
        sub_menu_text[player_i] = ""
        
        if (item_is_equipable(item)){
          if (cursor_pos[player_i] &gt;= 6){
            ds_list_add(sub_menu_options[player_i], sub_menu.equip)
            sub_menu_text[player_i] += "Equip"+chr(10)
          }else{
            ds_list_add(sub_menu_options[player_i], sub_menu.unequip)
            sub_menu_text[player_i] += "Unequip"+chr(10)
          }
        }
        
        if (item_is_consumable(item)){
          ds_list_add(sub_menu_options[player_i], sub_menu.consume)
          sub_menu_text[player_i] += "Consume"+chr(10)
        }
        
        if (item_is_modifier(item)){
          ds_list_add(sub_menu_options[player_i], sub_menu.combine)
          sub_menu_text[player_i] += "Combine"+chr(10)
        }
        
        ds_list_add(sub_menu_options[player_i], sub_menu.drop)
        sub_menu_text[player_i] += "Drop"+chr(10)
        
        
      }
      
      //sub menu surface
      if (sub_menu_surface[player_i] = noone)
      || !surface_exists(sub_menu_surface[player_i]){
        //if the sub menu just spawned then create the surface for it
        var xx = sub_menu_x[player_i];
        var yy = sub_menu_y[player_i];
        var ww = sub_menu_w[player_i];
        var hh = sub_menu_h[player_i];
        var _gui_scale = gui_scale[player_i];
        sub_menu_surface[player_i] = surface_create(ww, hh)
        
        surface_set_target(sub_menu_surface[player_i])
        
        scr_draw_9slices_ext(spr_menu_9slice, 0, 0, 0, ww, hh, c_white, 1, _gui_scale)
        draw_set_font(global.font_menu)
        var art_border = (sprite_get_height(spr_menu_9slice) / 3)*_gui_scale;
        var cursor_area = sprite_get_width(spr_sub_menu_cursor)*1.5*_gui_scale;
        
        draw_text_transformed(art_border+1+cursor_area, art_border+1, sub_menu_text[player_i], _gui_scale, _gui_scale, 0)
        
        surface_reset_target()
      }
      
      
      //lore surface
      if (lore_surface[player_i] = noone)
      || !surface_exists(lore_surface[player_i]){
        //if the sub menu just spawned then create the surface for it
        var xx = lore_x[player_i];
        var yy = lore_y[player_i];
        var ww = lore_w[player_i];
        var hh = lore_h[player_i];
        var _gui_scale = gui_scale[player_i];
        lore_surface[player_i] = surface_create(ww, hh)
        
        surface_set_target(lore_surface[player_i])
        
        scr_draw_9slices_ext(spr_menu_9slice, 0, 0, 0, ww, hh, c_white, 1, _gui_scale)
        draw_set_font(global.font_menu)
        var art_border = (sprite_get_height(spr_menu_9slice) / 3)*_gui_scale;
        draw_text_transformed(art_border+1, art_border+1, sub_menu_text[player_i], _gui_scale, _gui_scale, 0)
        
        surface_reset_target()
        
      }
      
      
      
      //we are drawing the sub menu animation in the gui draw event
      
      
      //update cursor possition
      if (sub_menu_spawned[player_i])
      &amp;&amp; !(sub_menu_is_equiping[player_i] || sub_menu_is_combining[player_i])
      {
        if (obj_controller.up_pressed[player_i] != 0)
        || (obj_controller.up_held[player_i] != 0)
        {
          sub_menu_cursor_pos[player_i] += -1
          if (sub_menu_cursor_pos[player_i] &lt; 0){
            sub_menu_cursor_pos[player_i] = ds_list_size(sub_menu_options[player_i]) - 1
          }
        }
        //down
        if (obj_controller.down_pressed[player_i] != 0)
        || (obj_controller.down_held[player_i] != 0)
        {
          sub_menu_cursor_pos[player_i] += 1
          if (sub_menu_cursor_pos[player_i] &gt;= ds_list_size(sub_menu_options[player_i])){
            sub_menu_cursor_pos[player_i] = 0
          }
        }
        
        if (obj_controller.menu_select_pressed[player_i] != 0)
        &amp;&amp; (selected_this_frame[player_i] = false){
          selected_this_frame[player_i] = true;
          
          var events_list = sub_menu_options[player_i]
          var pos = sub_menu_cursor_pos[player_i]
          var event = events_list[| pos]
          
          switch event{
            case sub_menu.equip:
              sub_menu_is_equiping[player_i] = true
              sub_menu_event_inv_cursor_pos[player_i] = cursor_pos[player_i]
              //move the cursor to a reasonable spot depending on the item
              if item_is_armor(selected_item_map[player_i]){
                var item = selected_item_map[player_i];
                var item_type = item[? "item_type"]
                
                switch item_type
                {
                  case item_type_armor_head:
                    sub_menu_event_inv_cursor_pos[player_i] = equip.head
                  break;
                  case item_type_armor_body:
                    sub_menu_event_inv_cursor_pos[player_i] = equip.body
                  break;
                  case item_type_armor_boggle:
                    sub_menu_event_inv_cursor_pos[player_i] = equip.boggle
                  break;
                }
                
              }else{ //if it's not an armor
                sub_menu_event_inv_cursor_pos[player_i] = 5
              }
            break;
            case sub_menu.unequip:
              item_unequip(nbt_data[player_i], cursor_pos[player_i])
              sub_menu_spawned[player_i] = false
              sub_menu_anim_finished[player_i] = false
              sub_menu_cursor_pos[player_i] = 0
              in_sub_menu[player_i] = false
              selected_item_map[player_i] = noone
              surface_free(sub_menu_surface[player_i])
              surface_free(lore_surface[player_i])
              sub_menu_surface[player_i] = noone
              lore_surface[player_i] = noone
            break;
            case sub_menu.consume:
              
            break;
            case sub_menu.combine:
              sub_menu_is_combining[player_i] = true
              sub_menu_event_inv_cursor_pos[player_i] = cursor_pos[player_i]
            break;
            case sub_menu.drop:
              //find the player
              var player = menu_player_id[player_i];
              
              //spawn the item
              item_spawn(selected_item_map[player_i], player.x, player.y, 5, player.direction, player)
              
              //delete the item from the inventory
              var _nbt = nbt_data[player_i]
              var _inv = _nbt[? "inventory"]
              ds_list_delete(_inv, cursor_pos[player_i]-6) 
              
              //leave the sub menu
              sub_menu_spawned[player_i] = false
              sub_menu_anim_finished[player_i] = false
              sub_menu_cursor_pos[player_i] = 0
              in_sub_menu[player_i] = false
              selected_item_map[player_i] = noone
              surface_free(sub_menu_surface[player_i])
              surface_free(lore_surface[player_i])
              sub_menu_surface[player_i] = noone
              lore_surface[player_i] = noone
              
              //update the menu
              update_menus = true
            break;
            
          }
        }
      }
      
      //check to see if the player has selected anything
      
      //check to see if the player has backed out of the submenu
      if (sub_menu_spawned[player_i] = true)
      &amp;&amp; (in_sub_menu[player_i] = true)
      &amp;&amp; (sub_menu_is_equiping[player_i] = false)
      &amp;&amp; (sub_menu_is_combining[player_i] = false)
      {
        if (obj_controller.menu_back_pressed[player_i] != 0)
        &amp;&amp; backed_this_frame[player_i] = false{
          backed_this_frame[player_i] = true;
          
          sub_menu_spawned[player_i] = false
          sub_menu_anim_finished[player_i] = false
          sub_menu_cursor_pos[player_i] = 0
          in_sub_menu[player_i] = false
          selected_item_map[player_i] = noone
          surface_free(sub_menu_surface[player_i])
          surface_free(lore_surface[player_i])
          sub_menu_surface[player_i] = noone
          lore_surface[player_i] = noone
        }
      }
      
      
      
      //check to see if the player has selected something with the submenu's equip/combine event
      if (sub_menu_spawned[player_i] = true)
      &amp;&amp; (in_sub_menu[player_i] = true)
      &amp;&amp; (sub_menu_is_equiping[player_i] || sub_menu_is_combining[player_i])
      {
        if (obj_controller.menu_select_pressed[player_i] != 0)
        &amp;&amp; selected_this_frame[player_i] = false{
          selected_this_frame[player_i] = true;
          
          var inv_loc = cursor_pos[player_i]-6
          
          
          if (sub_menu_is_equiping[player_i]) {
            sub_menu_is_equiping[player_i] = false
            item_equip(nbt_data[player_i], sub_menu_event_inv_cursor_pos[player_i], cursor_pos[player_i])
            
            sub_menu_spawned[player_i] = false
            sub_menu_anim_finished[player_i] = false
            sub_menu_cursor_pos[player_i] = 0
            in_sub_menu[player_i] = false
            selected_item_map[player_i] = noone
            surface_free(sub_menu_surface[player_i])
            surface_free(lore_surface[player_i])
            sub_menu_surface[player_i] = noone
            lore_surface[player_i] = noone
          }
          if (sub_menu_is_combining[player_i]) {
            sub_menu_is_combining[player_i] = false
          }
        }
      }
      
      
      //check to see if the player has backed out of the submenu's equip/combine event
      if (sub_menu_spawned[player_i] = true)
      &amp;&amp; (in_sub_menu[player_i] = true)
      &amp;&amp; (sub_menu_is_equiping[player_i] || sub_menu_is_combining[player_i])
      {
        if (obj_controller.menu_back_pressed[player_i] != 0)
        &amp;&amp; backed_this_frame[player_i] = false{
          backed_this_frame[player_i] = true;
          
          if (sub_menu_is_equiping[player_i]) {
            sub_menu_is_equiping[player_i] = false
          }
          if (sub_menu_is_combining[player_i]) {
            sub_menu_is_combining[player_i] = false
          }
        }
      }
    }
    
  }
}










</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw the primary menu
for (var player_i = 0; player_i &lt; global.numberOfLocalPlayers; player_i++){
  
  draw_set_alpha(1)
  draw_set_color(c_white)
  draw_set_halign(fa_left);
  draw_set_valign(fa_top);
  
  
  if (menu_open[player_i]){
    if surface_exists(menu_background_surface[player_i]){
      //display_set_gui_size(window_get_width(),window_get_height());
      draw_set_alpha(1)
      
      if (obj_camera_control.smooth_camera){
       var res_scale = 1/obj_camera_control.upscale_val
      }else{
        var res_scale = 1
      }
      
      var vx = view_xport[player_i]
      var vy = view_yport[player_i]
      var vw = view_wport[player_i]
      var vh = view_hport[player_i]
      
      
      var _gui_scale = gui_scale[player_i]
      var w = surface_get_width(menu_background_surface[player_i])*_gui_scale
      var menu_x_off = vx+floor((vw-w)/2)
      var menu_y_off = vy
      
      //draw the menu backdrop
      //draw_surface(menu_background_surface[player_i], 0, 0)
      draw_surface_stretched(menu_background_surface[player_i], 
                             menu_x_off, 
                             menu_y_off, 
                             surface_get_width(menu_background_surface[player_i])*_gui_scale-1, 
                             surface_get_height(menu_background_surface[player_i])*_gui_scale-1
                             )
                             
      //draw the inventory grid
      var inv_x_off = menu_x_off + inventory_x_off[player_i]*_gui_scale
      var inv_y_off = menu_y_off + inventory_y_off[player_i]*_gui_scale
      
      
      var inventory_view_y_off = 0
      
      var xscale = (surface_get_width(menu_inventory_surface[player_i])*_gui_scale-1) / (surface_get_width(obj_menu.menu_inventory_surface[player_i])*_gui_scale);
      var yscale = (surface_get_height(menu_inventory_surface[player_i])*_gui_scale-1) / (surface_get_height(obj_menu.menu_inventory_surface[player_i])*_gui_scale);
      
      var height = min(inv_height[player_i],
                       surface_get_height(menu_inventory_surface[player_i])
                       )
      
      draw_surface_part_ext(menu_inventory_surface[player_i], 
                             0,
                             inventory_view_y_off,
                             inv_width[player_i],
                             height,
                             inv_x_off,
                             inv_y_off,
                             xscale*_gui_scale,
                             yscale*_gui_scale,
                             c_white,
                             1
                             )
      /*
      draw_surface_stretched(menu_inventory_surface[player_i], 
                             inv_x_off, 
                             inv_y_off, 
                             inv_width[player_i]*_gui_scale-1, 
                             inv_height[player_i]*_gui_scale-1
                             )
      */
      
      //draw the cursor
      var art_border = sprite_get_height(spr_menu_9slice) / 3;
      var icon_height = sprite_get_height(spr_menu_tab_icons)
      
      //set the cursor location that we're going to be handling
      if (sub_menu_is_equiping[player_i] || sub_menu_is_combining[player_i]){
        var cursor_loc = sub_menu_event_inv_cursor_pos[player_i]
      }else{
        var cursor_loc = cursor_pos[player_i]
      }
      
      
      if (cursor_loc &lt; 6){
        var cursor_size = 16*_gui_scale
        
        var xx = menu_x_off+ (art_border*2 + ((16+art_border+art_border)*(cursor_loc mod 3)))*_gui_scale;
        var yy = menu_y_off+ (icon_height + art_border + art_border + ((16+art_border+art_border)*(cursor_loc div 3)))*_gui_scale;
        var ww = 16*_gui_scale;
        var hh = 16*_gui_scale;
        
      }else{//inventory grid section
        var cursor_size = 32*_gui_scale
        var cursor_offset = (cursor_loc-6);
        var inv_slot_border = (1*_gui_scale)
        var inv_slot = sprite_get_width(spr_menu_inventory_slot)
        
        var xx = inv_x_off+inv_slot_border + (inv_slot*(cursor_offset mod inv_items_per_row[player_i])*_gui_scale);
        var yy = inv_y_off+inv_slot_border + (inv_slot*(cursor_offset div inv_items_per_row[player_i])*_gui_scale);
        var ww = 32*_gui_scale;
        var hh = 32*_gui_scale;
      }
      
      
      
      draw_sprite_stretched(spr_menu_cursor, 0, (vx+xx), (vy+yy), ww, hh)
      
    }
  }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw the sub menu

for (player_i = 0; player_i &lt;= global.numberOfLocalPlayers; player_i++){
  if (menu_open[player_i])
  &amp;&amp; in_sub_menu[player_i]{
    
    draw_set_alpha(1)
    draw_set_color(c_white)
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    
    //if an item has been selected
    if (selected_item_map[player_i] != noone){
      
      var vx = view_xport[player_i]
      var vy = view_yport[player_i]
      var vw = view_wport[player_i]
      var vh = view_hport[player_i]
      
      var _gui_scale = gui_scale[player_i]
      var w = surface_get_width(menu_background_surface[player_i])*_gui_scale
      var menu_x_off = vx+floor((vw-w)/2)
      var menu_y_off = vy
      
      var xx = sub_menu_x[player_i]+menu_x_off;
      var yy = sub_menu_y[player_i]+menu_y_off;
      var ww = sub_menu_w[player_i];
      var hh = sub_menu_h[player_i];
      
      
      //if the sub menu is done with it's open animation then just draw it normally in place
      if (sub_menu_anim_finished[player_i] = true){
        texture_set_interpolation(true)  
        draw_surface_stretched(sub_menu_surface[player_i], xx, yy, ww-1, hh-1)
        texture_set_interpolation(false)
      }
      
      
      //sub menu's open annimation
      if (sub_menu_spawned[player_i] = true)
      &amp;&amp; (sub_menu_anim_finished[player_i] = false){
        var sub_menu_anim_time = room_speed * 0.25
        
        var spawn_y = yy+(hh/2);
        var anim_perc = sub_menu_anim_frame[player_i] / sub_menu_anim_time;
        
        var multiplier = scr_snappy_anim(anim_perc)
        var anim_y = spawn_y - (hh/2)*multiplier
        var draw_h_section = clamp((yy-anim_y)+hh, 0, hh)
        show_debug_player(0, "multiplier = "+string(multiplier))
        
        texture_set_interpolation(true)
        draw_surface_part_ext(sub_menu_surface[player_i], 0, 0, ww, draw_h_section, xx, anim_y, (ww-1)/ww, (draw_h_section-1)/draw_h_section, c_white, 1)
        texture_set_interpolation(false)
        
        sub_menu_anim_frame[player_i] += 1*lag()
        
        if (sub_menu_anim_frame[player_i] &gt;= sub_menu_anim_time){
          sub_menu_anim_frame[player_i] = 0
          sub_menu_anim_finished[player_i] = true
        }
      }
      
      //draw the cursor
      var art_border = (sprite_get_height(spr_menu_9slice) / 3)*_gui_scale;
      var cursor_area = sprite_get_width(spr_sub_menu_cursor)*1.25*_gui_scale;
      var cursor_width = sprite_get_width(spr_sub_menu_cursor)*_gui_scale
      var cursor_height = sprite_get_height(spr_sub_menu_cursor)*_gui_scale
      
      if (!sub_menu_is_equiping[player_i])
      &amp;&amp; (!sub_menu_is_combining[player_i]){
        var cursor_x_off = wave(0, cursor_area-cursor_width, 1, 0) + (cursor_area-cursor_width)/2
      }else{
        var cursor_x_off = (cursor_area-cursor_width) + (cursor_area-cursor_width)/2
      }
      var cursor_xx = sub_menu_x[player_i]+menu_x_off + art_border+cursor_x_off;
      
      if sub_menu_anim_finished[player_i] {
        var cursor_yy = sub_menu_y[player_i]+art_border
      }else{
        var cursor_yy = anim_y+art_border;
      }
      var cursor_y_off = (sub_menu_cursor_pos[player_i])*cursor_height
      draw_sprite_stretched(spr_sub_menu_cursor, 0, cursor_xx, cursor_yy+cursor_y_off, cursor_width, cursor_height)
    }
  }
}











</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw the lore text box

///draw the sub menu

for (player_i = 0; player_i &lt;= global.numberOfLocalPlayers; player_i++){
  if (menu_open[player_i])
  &amp;&amp; in_sub_menu[player_i]{
    
    draw_set_alpha(1)
    draw_set_color(c_white)
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    
    //if an item has been selected
    if (selected_item_map[player_i] != noone){
      
      var vx = view_xport[player_i]
      var vy = view_yport[player_i]
      var vw = view_wport[player_i]
      var vh = view_hport[player_i]
      
      var _gui_scale = gui_scale[player_i]
      var w = surface_get_width(menu_background_surface[player_i])*_gui_scale
      var menu_x_off = vx+floor((vw-w)/2)
      var menu_y_off = vy
      
      var xx = lore_x[player_i]+menu_x_off;
      var yy = lore_y[player_i]+menu_y_off;
      var ww = lore_w[player_i];
      var hh = lore_h[player_i];
      
      
      //if the sub menu is done with it's open animation then just draw it normally in place
      if (sub_menu_anim_finished[player_i] = true){
        texture_set_interpolation(true)
        draw_surface_stretched(lore_surface[player_i], xx, yy, ww-1, hh-1)
        texture_set_interpolation(false)
      }
      
      
      //sub menu's open annimation
      if (sub_menu_spawned[player_i] = true)
      &amp;&amp; (sub_menu_anim_finished[player_i] = false){
        var sub_menu_anim_time = room_speed * 0.25
        
        var spawn_y = yy+(hh/2);
        var anim_perc = sub_menu_anim_frame[player_i] / sub_menu_anim_time;
        
        var multiplier = scr_snappy_anim(anim_perc)
        var anim_y = spawn_y - (hh/2)*multiplier
        var draw_h_section = clamp((yy-anim_y)+hh, 0, hh)
        show_debug_player(0, "multiplier = "+string(multiplier))
        
        texture_set_interpolation(true)
        //draw_surface(lore_surface[player_i], 0, 0)
        draw_surface_part_ext(lore_surface[player_i], 0, 0, ww, draw_h_section, xx, anim_y, (ww-1)/ww, (draw_h_section-1)/draw_h_section, c_white, 1)
        texture_set_interpolation(false)
        
        sub_menu_anim_frame[player_i] += 1*lag()
        
        if (sub_menu_anim_frame[player_i] &gt;= sub_menu_anim_time){
          sub_menu_anim_frame[player_i] = 0
          sub_menu_anim_finished[player_i] = true
        }
      }
    }
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
