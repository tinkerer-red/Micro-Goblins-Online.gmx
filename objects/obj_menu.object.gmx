<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init inventory

//we initialize this variable as false because we check to see if its an array in the step event
menu_background_surface = false;


//for every player
var player_i
for (player_i = 0; player_i &lt;= 8; player_i++)
{
  //first we need to find out if the player has loaded a save file.
  var player_had_loaded = false;
  
  //load save file
  //if the player loaded a save file then we need to populate this list with the saved inventory
  if (player_had_loaded){
    var file_name = "name.save"
  }else{
    var file_name = false
  }
  
  //load the inventory of the player
  nbt_data[player_i] = nbt_data_load(file_name)
  
  prev_inv_items_per_row[player_i] = 0
  inv_items_per_row[player_i] = 0
  max_items[player_i] = 20
  menu_open[player_i] = 0
  cursor_pos[player_i] = 5
  tab_pos[player_i] = 0
  sub_menu_cursor_pos[player_i] = 0
  in_sub_menu[player_i] = 0
  
}
  
  
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Rescale the menus


if window_resized()
|| !is_array(menu_background_surface)
|| !surface_exists(menu_background_surface[0]){
  
  //text transphormer
  var text_scaling = 0.5
  
  if (obj_camera_control.smooth_camera){
   var res_scale = 1/obj_camera_control.upscale_val
  }else{
    var res_scale = 1
  }
  
  
  //for every player
  var player_i
  for (player_i = 0; player_i &lt; global.numberOfLocalPlayers; player_i++)
  {
    
    
    //most importantly we will need to load the NBT data of the player to get their inventory information!
    var nbt = nbt_data[player_i];
    
    
    
    //get the coords of the view, and width and height
    v_x[player_i] = view_xport[player_i]
    v_y[player_i] = view_yport[player_i]
    v_w[player_i] = view_wport[player_i]
    v_h[player_i] = view_hport[player_i]
    
    //grab the size of the art boarder, in the future this might make a difference with unique art styles in the settings
    var art_border = sprite_get_height(spr_menu_9slice) / 3;
    
    //grab the volume of the screen size
    //determine the scaling in which to use, assuming we dont have the value set in the settings
    
    /////find the scale in which to use (unless the player has specified the ui scale to use)
    var ideal_width = 188
    var ideal_height = 240
    var scale1 = v_w[player_i] div ideal_width;
    var scale2 = v_h[player_i] div ideal_height;
    gui_scale[player_i] = floor(min(scale1, scale2));
    
    if (gui_scale[player_i] &lt; 1) {
      //setting this to 0.5 actually causes the original surface to end up being 2x the standard size, but oh well
      gui_scale[player_i] = 0.5
    }
    
    //once we know the scale, lets reset the view height to fix some scaling issues
    v_w[player_i] = floor(v_w[player_i]/gui_scale[player_i])
    v_h[player_i] = floor(v_h[player_i]/gui_scale[player_i])
    
    
    //calculate the space which will actually be viable,
    
    //find the tab sizes
    tab_height[player_i] = sprite_get_height(spr_menu_tab_icons);
    tab_width[player_i] = sprite_get_width(spr_menu_tab_icons);
    
    //remove the art boarder from total sizes
    menu_width[player_i] = v_w[player_i] - 8;
    menu_height[player_i] = v_h[player_i] - art_border - art_border - tab_height[player_i];
    
    //find the info box size
    info_section_width[player_i] = (16+art_border+art_border)*3 //3 sprite sizes + 2 borders on each side, 3*16 + 4*2*3
    
    //find the scrollbar size
    scroll_bar_width[player_i] = (2+art_border+art_border) //2 pixels for the bar it's self and 4 pixels on each side for the art
    
    //inventory size
    inv_width[player_i] = menu_width[player_i] - info_section_width[player_i] - scroll_bar_width[player_i];
    inv_height[player_i] = menu_height[player_i];
    
    //draw the inventory box (temporary untill we know the calculations are correct)
    var x1 = art_border+info_section_width[player_i];
    var y1 = art_border + tab_height[player_i];
    var x2 = v_w[player_i]-scroll_bar_width[player_i]-art_border;
    var y2 = v_h[player_i]-(art_border);
    
    //store the previous items per row so we know if we need to update the inventory grid
    prev_inv_items_per_row[player_i] = inv_items_per_row[player_i]
    
    inv_items_per_row[player_i] = min((x2-x1) div 34, 6)
    inv_width[player_i]       = inv_items_per_row[player_i]*34;
    inv_height[player_i]      = y2-y1;
    
    inventory_x_off[player_i] = x1+2;
    inventory_y_off[player_i] = y1;
    
    
    
    var surface_width = info_section_width[player_i] + art_border*2 + inv_width[player_i] +scroll_bar_width[player_i] +2;
    
    //once we have all the relevant information lets create a surfaces so we dont have to draw all of this every frame
    menu_background_surface[player_i] = surface_create(surface_width, v_h[player_i]);
    
    
  //this leaves us only to draw on the surfaces,
    //for the background surface draw all the static objects which are unchanging
    surface_set_target(menu_background_surface[player_i])
    
    
    //first we need to draw the tabs since they are furthest in the back
    var icon_width = sprite_get_width(spr_menu_tab_icons)
    var icon_height = sprite_get_height(spr_menu_tab_icons)
    var tab_count = 6
    var x_offset = (surface_width-icon_width*tab_count)/2
    for(var icon_index = 0; icon_index &lt; tab_count; icon_index++){
      var x1 = x_offset+(icon_width*icon_index)
      var y1 = 0
      
      draw_sprite_ext(spr_menu_tab_icons, icon_index, x1, y1, 1, 1, 0, c_white, 1)
    }
    
    
    
    //now draw the entire background of the menu
    scr_draw_9slices_ext(spr_menu_9slice, 0, 0, icon_height, surface_width, v_h[player_i], c_white, 1, 1)
    
    
    
    //build a temproary enum for making this easier
    enum equip{
      head,
      body,
      boggle,
      item_a,
      item_b,
      item_c
    }
    
    //now draw the 6 equipment slots
    var x_off = art_border;
    var y_off = icon_height + art_border;
    for(var equip_y = 0; equip_y &lt; 2; equip_y++)     for(var equip_x = 0; equip_x &lt; 3; equip_x++) {
      var x1 = x_off+ ((16+art_border+art_border)*equip_x)
      var y1 = y_off+ ((16+art_border+art_border)*equip_y) 
      var x2 = x1 + (16+art_border+art_border)
      var y2 = y1 + (16+art_border+art_border)
      
      //draw the inventory slot for the item
      scr_draw_9slices_ext(spr_menu_9slice, 0, x1, y1, x2, y2, c_white, 1, 1)
      
      switch (equip_x+(equip_y*3)){
        case equip.head:   var item_key = "armor_head";   break;
        case equip.body:   var item_key = "armor_body";   break;
        case equip.boggle: var item_key = "armor_boggle"; break;
        case equip.item_a: var item_key = "held_item_a";  break;
        case equip.item_b: var item_key = "held_item_b";  break;
        case equip.item_c: var item_key = "held_item_c";  break;
        default:           var item_key = "";             break; //this is only here to prevent reading from a bad section of ram
      }
      
      //draw the item
      draw_item(nbt[? item_key], x1+art_border, y1+art_border, 16, 16)
      //show_debug_message("nbt[? "+item_key+"] = "+json_encode(nbt[? item_key]))
    }
    
    
    //draw the text box for lore and modifiers
    var x1 = x_off
    var y1 = y2+1+info_section_width[player_i]+1
    var x2 = x1+info_section_width[player_i]
    var y2 = v_h[player_i]-art_border
    scr_draw_9slices_ext(spr_menu_9slice, 0, x1, y1, x2, y2, c_white, 1, 1)
    
    
    //draw the scroll bars boarder
    var x2 = surface_width-art_border;
    var y2 = v_h[player_i]-art_border;
    var x1 = x2 - scroll_bar_width[player_i];
    var y1 = art_border + icon_height;
    scr_draw_9slices_ext(spr_menu_9slice, 0, x1, y1, x2, y2, c_white, 1, 1)
    
    
    //draw the bounding box for the inventory for debugging purposes
    scr_draw_9slices_ext(spr_menu_9slice,
                         0, 
                         inventory_x_off[player_i], 
                         inventory_y_off[player_i], 
                         inventory_x_off[player_i]+inv_width[player_i], 
                         inventory_y_off[player_i]+inv_height[player_i], 
                         c_white, 
                         1, 
                         1)
    
    
    
    //once we're done drawing reset the surface target
    surface_reset_target()
    
    
    
    
    
    
    
    
    //for the inventory, sort all the items into a grid, then cycle through them all drawing the required items, of course the surface only needs the data that it can see, no reason to draw items which arent going to show up since a player could be dropping items before they are even seen. This should be its own function to prevent to many draw calls each frame and anytime something is dropped we can update it all with the same script.
    
    max_items[player_i] = nbt[? "max_inventory_slots"];
    var height = ceil(max_items[player_i]/inv_items_per_row[player_i])*34;
    
    //using the left over variables we made lets create the surface
    menu_inventory_surface[player_i] = surface_create(inv_width[player_i], height);
    
    surface_set_target(menu_inventory_surface[player_i])
    
    
    
    
    //now lets populate that checkerboard with the items
    
      
    //first check to see if the items per row has even changed,
    //  if it hasn't then there is no reason to update the surface
//    if (prev_inv_items_per_row[player_i] != inv_items_per_row[player_i])
//    || (max_items[player_i] != nbt[? "max_inventory_slots"]){
      
        var max_y = ceil(max_items[player_i]/inv_items_per_row[player_i]);
        var item_counter = 0;
        var inventory_list = nbt[? "inventory"]
        
        var is_finished = false;
        
        for (var yy = 0; yy &lt; max_y; yy++){
          for (var xx = 0; xx &lt; inv_items_per_row[player_i]; xx++){
            
            var x1 = xx*34;
            var y1 = yy*34;
            
            //draw the inventory slots which are open
            draw_sprite(spr_menu_inventory_slot, 0, x1, y1)
            
            //draw the sprite of the item, with the correct hue
            draw_item(inventory_list[| item_counter], x1+1, y1+1, 32, 32)
            
            //acount for how many items we cycled through, then break when we reached the max
            item_counter++
            if (item_counter = max_items[player_i]) {
              is_finished = true;
              break;
            }
          }
          if (is_finished) break;
        }
      
//      }
    
    
    surface_reset_target()
  }
    
    
    
}


















</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///handle cursor movement

for (player_i = 0; player_i &lt;= 8; player_i++)
{
  if (menu_open[player_i]){
    if (!in_sub_menu[player_i]){
      //handle the curser movement for the equipment slots
      if (cursor_pos[player_i] &lt; 6){
        //up
        if (obj_controller.up_pressed[player_i] != 0)
        || (obj_controller.up_held[player_i] != 0)
        {
          if (cursor_pos[player_i] &gt; 2){
            cursor_pos[player_i] += -3
          }
        }
        //down
        if (obj_controller.down_pressed[player_i] != 0)
        || (obj_controller.down_held[player_i] != 0)
        {
          if (cursor_pos[player_i] &lt; 3){
            cursor_pos[player_i] += 3
          }
        }
        //left
        if (obj_controller.left_pressed[player_i] != 0)
        || (obj_controller.left_held[player_i] != 0)
        {
          //prevent the cursor from cycling to the top right, when on the bottom left
          if (cursor_pos[player_i] != 3)
          &amp;&amp; (cursor_pos[player_i] != 0){
            cursor_pos[player_i] += -1
          }
        }
        //right
        if (obj_controller.right_pressed[player_i] != 0)
        || (obj_controller.right_held[player_i] != 0)
        {
          if (cursor_pos[player_i] != 2){
            //if it's the second inventory row, go ahead and snap it to the second inv row pos
            if (cursor_pos[player_i] = 5){
              cursor_pos[player_i] = 6 + inv_items_per_row[player_i]
            }else{
              cursor_pos[player_i] += 1
            }
          }else{
            cursor_pos[player_i] = 6
          }
        }
        
        
      
      }else{
        //if we're in the inventory grid
        
        //up
        if (obj_controller.up_pressed[player_i] != 0)
        || (obj_controller.up_held[player_i] != 0)
        {
          //prevent pressing up on the top row
          if ((cursor_pos[player_i]-6) div inv_items_per_row[player_i] &gt; 0){
            cursor_pos[player_i] += -inv_items_per_row[player_i]
          }
        }
        //down
        if (obj_controller.down_pressed[player_i] != 0)
        || (obj_controller.down_held[player_i] != 0)
        {
          cursor_pos[player_i] += inv_items_per_row[player_i]
          cursor_pos[player_i] = clamp(cursor_pos[player_i], 0, max_items[player_i]+6-1)
        }
        //left
        if (obj_controller.left_pressed[player_i] != 0)
        || (obj_controller.left_held[player_i] != 0)
        {
          //prevent going left
          if ((cursor_pos[player_i]-6) mod inv_items_per_row[player_i] &gt; 0){
            cursor_pos[player_i] += -1
          }else{
          //if we are all the way left, then jump to the correct possition
            if ((cursor_pos[player_i]-6) div inv_items_per_row[player_i] = 0){
            //if were on the first row go to the first equipment's row
              cursor_pos[player_i] = 2
            }else{
            //else second row
              cursor_pos[player_i] = 5
            }
          }
        }
        //right
        if (obj_controller.right_pressed[player_i] != 0)
        || (obj_controller.right_held[player_i] != 0)
        {
            //prevent going over the inventory size
          if (cursor_pos[player_i] &lt; max_items[player_i]+6-1)
            //prevent cycling back to the left from the right
          &amp;&amp; ((cursor_pos[player_i]-6) mod inv_items_per_row[player_i] != inv_items_per_row[player_i]-1)
          {
            cursor_pos[player_i] += 1
          }
          
          
          
        }
        
      }
      
      
      
      //once all the movements are handled, we can work on the selection options
      
      
      
    } //end of !sub_menu check
    
  }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///open and close the menu

for (player_i = 0; player_i &lt;= 8; player_i++)
{
  if (menu_open[player_i]){
    if (!in_sub_menu[player_i]){
      if (obj_controller.menu_back_pressed[player_i]){
        menu_open[player_i] = false
      }
    }
  
  }else{ //if the menu isnt open
    if (obj_controller.menu_open_pressed[player_i]){
      menu_open[player_i] = true
    }
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>for (player_i = 0; player_i &lt;= 8; player_i++)
{
  if (menu_open[player_i]){
    
    for (player_i = 0; player_i &lt; global.numberOfLocalPlayers; player_i++)
    {
      if surface_exists(menu_background_surface[player_i]){
        //display_set_gui_size(window_get_width(),window_get_height());
        draw_set_alpha(1)
        
        if (obj_camera_control.smooth_camera){
         var res_scale = 1/obj_camera_control.upscale_val
        }else{
          var res_scale = 1
        }
        
        var vx = view_xport[player_i]
        var vy = view_yport[player_i]
        var vw = view_wport[player_i]
        var vh = view_hport[player_i]
        
        
        var _gui_scale = gui_scale[player_i]
        var w = surface_get_width(menu_background_surface[player_i])*_gui_scale
        var menu_x_off = vx+floor((vw-w)/2)
        var menu_y_off = vy
        
        //draw the menu backdrop
        //draw_surface(menu_background_surface[player_i], 0, 0)
        draw_surface_stretched(menu_background_surface[player_i], 
                               menu_x_off, 
                               menu_y_off, 
                               surface_get_width(menu_background_surface[player_i])*_gui_scale-1, 
                               surface_get_height(menu_background_surface[player_i])*_gui_scale-1
                               )
                               
        //draw the inventory grid
        var inv_x_off = menu_x_off + inventory_x_off[player_i]*_gui_scale
        var inv_y_off = menu_y_off + inventory_y_off[player_i]*_gui_scale
        
        
        var inventory_view_y_off = 0
        
        var xscale = (surface_get_width(menu_inventory_surface[player_i])*_gui_scale-1) / (surface_get_width(obj_menu.menu_inventory_surface[player_i])*_gui_scale);
        var yscale = (surface_get_height(menu_inventory_surface[player_i])*_gui_scale-1) / (surface_get_height(obj_menu.menu_inventory_surface[player_i])*_gui_scale);
        
        var height = min(inv_height[player_i],
                         surface_get_height(menu_inventory_surface[player_i])
                         )
        
        draw_surface_part_ext(menu_inventory_surface[player_i], 
                               0,
                               inventory_view_y_off,
                               inv_width[player_i],
                               height,
                               inv_x_off,
                               inv_y_off,
                               xscale*_gui_scale,
                               yscale*_gui_scale,
                               c_white,
                               1
                               )
        /*
        draw_surface_stretched(menu_inventory_surface[player_i], 
                               inv_x_off, 
                               inv_y_off, 
                               inv_width[player_i]*_gui_scale-1, 
                               inv_height[player_i]*_gui_scale-1
                               )
        */
        
        //draw the cursor
        var art_border = sprite_get_height(spr_menu_9slice) / 3;
        var icon_height = sprite_get_height(spr_menu_tab_icons)
        
        if (cursor_pos[player_i] &lt; 6){
          var cursor_size = 16*_gui_scale
          
          var xx = menu_x_off+ (art_border*2 + ((16+art_border+art_border)*(cursor_pos[player_i] mod 3)))*_gui_scale;
          var yy = menu_y_off+ (icon_height + art_border + art_border + ((16+art_border+art_border)*(cursor_pos[player_i] div 3)))*_gui_scale;
          var ww = 16*_gui_scale;
          var hh = 16*_gui_scale;
          
        }else{//inventory grid section
          var cursor_size = 32*_gui_scale
          var cursor_offset = (cursor_pos[player_i]-6);
          var inv_slot_border = (1*_gui_scale)
          var inv_slot = sprite_get_width(spr_menu_inventory_slot)
          
          var xx = inv_x_off+inv_slot_border + (inv_slot*(cursor_offset mod inv_items_per_row[player_i])*_gui_scale);
          var yy = inv_y_off+inv_slot_border + (inv_slot*(cursor_offset div inv_items_per_row[player_i])*_gui_scale);
          var ww = 32*_gui_scale;
          var hh = 32*_gui_scale;
        }
        
        
        
        draw_sprite_stretched(spr_menu_cursor, 0, (vx+xx), (vy+yy), ww, hh)
        
      }
    }
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
