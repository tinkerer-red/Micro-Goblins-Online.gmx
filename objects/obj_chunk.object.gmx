<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_chunk</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Init

/*
tile_layer_bottom_grid = -1
tile_layer_middle_grid = -1
tile_layer_top_grid = -1
tile_layer_decor_grid = -1
tile_layer_bottom_background_grid = -1
tile_layer_middle_background_grid = -1
tile_layer_top_background_grid = -1
tile_layer_decor_background_grid = -1
*/

chunk_data = -1
should_exist = true

//exterior chunk data
heightmap_grid = -1
structures_grid = -1

//interior chunk data
interior_grid_x = -1
interior_grid_y = -1
interior_map = -1



terrain_surface = -1

generated = false;

//for use with specialized drawing
has_water = false

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>image_alpha = 0.25
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Have Existential Crisis

//first find out if it's interior or exterior
if !is_interior(){
  //find out if you should even exist
  var margin = global.chunk_handler.margin
  var chunk_dist = global.chunk_handler.chunk_dist
  
  //is the player with in distance of you?
  var player = instance_nearest(x+sprite_width/2, y+sprite_height/2, obj_player)
  
  var closest_x = player.x div sprite_width
  var closest_y = player.y div sprite_height
  
  x_diff = closest_x - chunk_x
  y_diff = closest_y - chunk_y
  
  //if !point_in_rectangle(player.x, player.y, bbox_left-(sprite_width*(chunk_dist+margin)), bbox_top-(sprite_height*(chunk_dist+margin)), bbox_right+(sprite_width*(chunk_dist+margin)), bbox_bottom+(sprite_height*(chunk_dist+margin))){
  if not ((abs(x_diff) &lt; chunk_dist+margin) &amp;&amp; (abs(y_diff) &lt; chunk_dist+margin)){
    should_exist = false
    //show_debug_message("Chunk: ("+string(chunk_x)+","+string(chunk_y)+") Should NOT exists")
  }

}else{ //if it's an interior cell

  should_exist = chunk_interior_cell_existential_crisis_extension()


}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// /* Stagger the chunk Saving


var reach = global.chunk_handler.chunk_dist+global.chunk_handler.margin
var total_ideal_chunks = ((reach+reach+1)*(reach+reach+1))*global.numberOfLocalPlayers


if should_exist = false {
  if (global.chunk_handler.chunk_saved_this_frame = false &amp;&amp; global.chunk_handler.chunk_loaded_this_frame = false)
  || (generated = false)
  || (heightmap_grid = -1)
  || !enough_lag()
  || (instance_number(obj_chunk) &gt; total_ideal_chunks)
  {
    global.chunk_handler.chunk_saved_this_frame = true
    //show_debug_message("global.chunk_handler.chunk_saved_this_frame = false")
    event_user(1);
  }else{
    alarm_set(3, 1)
    //show_debug_message("global.chunk_handler.chunk_saved_this_frame = TRUE!!!")
    
  }
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Stagger the chunk Loading/Genning


if (global.chunk_handler.chunk_gen_this_frame = false)
|| !enough_lag()
{
  global.chunk_handler.chunk_gen_this_frame = true
  //show_debug_message("global.chunk_handler.chunk_loaded_this_frame = false")
  
  event_user(4);
  
}else{
  alarm_set(2, 1)
  
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Stagger the chunk gen

if (global.chunk_handler.chunk_gen_this_frame = false)
|| !enough_lag()
{
  global.chunk_handler.chunk_gen_this_frame = true
  //show_debug_message("global.chunk_handler.chunk_gen_this_frame = false")
  event_user(2);
}else{
  alarm_set(1, 1)
  //show_debug_message("global.chunk_handler.chunk_gen_this_frame = TRUE!!!")
  
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// /* Save to map every 2 minutes.
/*
if (global.chunk_handler.chunk_saved_this_frame = false){
  global.chunk_handler.chunk_saved_this_frame = true
  //chunk_save_to_map()
  //show_debug_message("Chunk: ("+string(chunk_x)+","+string(chunk_y)+") Saved")
  
  alarm_set(0, room_speed*60*2)
}else{
  alarm_set(0, 1)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// /* Loading
/*
//if ds_exists(async_load, ds_type_map){
if (async_load[? "id"] == loadid) {
  if (async_load[? "status"] = 1) { 
    show_debug_message("===============================TRYING TO LOAD!!!========================")
    chunk_data = ds_map_secure_load_buffer(load_buff);
    //if buffer_exists(load_buff)
    buffer_delete(load_buff);
    
    //show_debug_message("Chunk: ("+string(chunk_x)+","+string(chunk_y)+") async active")
    
    ///make sure to check the chunk to know it saved/loaded properly
    if !ds_exists(chunk_data, ds_type_map)
    || chunk_data[? "TileLayerBottom"] = undefined
    || chunk_data[? "TileLayerMiddle"] = undefined
    || chunk_data[? "TileLayerTop"] = undefined
    || chunk_data[? "TileLayerDecor"] = undefined
    || chunk_data[? "TileLayerBottomBackground"] = undefined
    || chunk_data[? "TileLayerMiddleBackground"] = undefined
    || chunk_data[? "TileLayerTopBackground"] = undefined
    || chunk_data[? "TileLayerDecorBackground"] = undefined
    {
      if ds_exists(chunk_data, ds_type_map) ds_map_destroy(chunk_data);
      show_debug_message("[Chunk][Load]: Chunk File ("+string(chunk_x)+","+string(chunk_y)+") was currupted, regenerating")
      chunk_data = chunk_generate()
    }
    
    
    alarm_set(1,1)
    //ds_map_destroy(async_load)
  }else{ // If there was an error loading, try to load again
    //ds_map_destroy(async_load)
    //show_debug_message("#####  THERE WAS AN ERROR LOADING!!!  #####")
    event_user(0)
    ///this may need to be fixed because it could cause for an infinate loop. but it works for now
  
  }
}
//}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Load Chunk data / Generate Chunk

//_filename = "default\"+"Worlds\"+string(world_name)+"\"+string(chunk_x)+","+string(chunk_y)+".chnk"
//_filename = "Worlds\"+string(world_name)+"\"+string(chunk_x)+","+string(chunk_y)+".chnk"
if (should_exist = false){
  event_user(1)
  exit;
}


//make sure the world's chunk map exists first
if ds_exists(global.chunk_handler.world_map, ds_type_map){
  
  //load the chunk data here
  if is_interior(x,y){ //if the cell is an exterior cell
    chunk_generate_interior_room()
  }else{
    chunk_generate()
  }
  
  alarm_set(1,1)
  
}else{
  
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create Chunk Surface  
  var tile_size = global.chunk_handler.tile_size
  //var width  = global.chunk_handler.world_width
  //var height = global.chunk_handler.world_height
  
  var grid_size_x = (sprite_width/tile_size)+2;
  var grid_size_y = (sprite_height/tile_size)+2;
  
  var x_off = bbox_left/tile_size+1;
  var y_off = bbox_top/tile_size+1;
  
  terrain_surface = surface_create(sprite_width, sprite_height)
  
  surface_set_target(terrain_surface)
  //*
  var tiles_x = sprite_width/tile_size;
  var tiles_y = sprite_height/tile_size;
  
  
if !is_interior(x,y){ //exterior cells
  
  if(ds_grid_get_max(heightmap_grid, 0,0,grid_size_x,grid_size_y) &lt;=1){ // If max value of our grid is less or equal 1, then poceed without autotiling.
    
  //First we'll copy the tile structure over to the Autotiling grid
    for(var i = 0; i &lt; tiles_x+2; i++){
      for(var j = 0; j &lt; tiles_y+2; j++){
        
        //heightmap tiles
        if(heightmap_grid[#i, j] &lt;= 0.15){    has_water = true;                 obj_chunk_supervisor.ats_grid[#i, j] = spr_tile_air;}
        else if(heightmap_grid[#i, j] &gt; 0.15 &amp;&amp; heightmap_grid[#i, j] &lt; 0.25)  {obj_chunk_supervisor.ats_grid[#i, j] = spr_sand_shadow;}
        else if(heightmap_grid[#i, j] &gt;= 0.25 &amp;&amp; heightmap_grid[#i, j] &lt;= 0.6) {obj_chunk_supervisor.ats_grid[#i, j] = spr_grass_shadow;}
        else if(heightmap_grid[#i, j] &gt; 0.6 &amp;&amp; heightmap_grid[#i, j] &lt;= 0.7)   {obj_chunk_supervisor.ats_grid[#i, j] = spr_rock_shadow;}
        else if(heightmap_grid[#i, j] &gt; 0.7 &amp;&amp; heightmap_grid[#i, j] &lt;= 0.8)   {obj_chunk_supervisor.ats_grid[#i, j] = spr_rock2_shadow;}
        else if(heightmap_grid[#i, j] &gt; 0.8)                                   {obj_chunk_supervisor.ats_grid[#i, j] = spr_snow_shadow;}//
        
        //dungeon tiles
        if (structure_grid[#i, j] = 1){ obj_chunk_supervisor.ats_grid[#i, j] = spr_tile_dungeon; }
        if (structure_grid[#i, j] = 2){ obj_chunk_supervisor.ats_grid[#i, j] = spr_tile_dungeon; }
        if (structure_grid[#i, j] = 3){ obj_chunk_supervisor.ats_grid[#i, j] = spr_tile_dungeon; }
        //if (structure_grid[#i, j] = 4){ heightmap_grid[#i, j] = spr_; }
      }
    }
  }
  
  ///Once the autotiling grid is populated, we can now draw the grid to the terrain surface
  ats_rectangle_update(obj_chunk_supervisor.ats_rectangle, 
                       obj_chunk_supervisor.ats_grid,
                       0, 0, tiles_x+2, tiles_y+2)
  
  //actually draw the surface
  surface_set_target(terrain_surface)
    ats_rectangle_draw(obj_chunk_supervisor.ats_rectangle, obj_chunk_supervisor.ats_grid, 1, 1, 16, 16, 0, 0);
  
  
  
  //once the surface is drawn to we can now cycle through the surface, hue shifting the drawn tiles to their biome and tempature based biomes
  draw_set_alpha(0.5);
  var tiles = one_chunk / one_tile;
  
  var surf_temp = surface_create(surface_get_width(terrain_surface), surface_get_height(terrain_surface))
  surface_copy(surf_temp, 0, 0, terrain_surface)
  
  
  //shader_set_brightness(chunk_x/64 -1)
  //shader_set_saturation(chunk_y/64 -1)
  
  for (var xx = 1; xx &lt; tiles+2; xx++) for (var yy = 1; yy &lt; tiles+2; yy++){
    var _x = (xx-1)*one_tile
    var _y = (yy-1)*one_tile
    
    var biome = biome_grid[# xx, yy]//*(sprite_get_width(spr_biome_color)-1)
    //var tempature = tempature_grid[# xx, yy]//*(sprite_get_height(spr_biome_color)-1)
    var biome_color = c_white;
    var test = round(256/10 *biome) * 10 -25.6
    biome_color = make_colour_rgb(test, test, test)
    
    draw_surface_part_ext(surf_temp, _x, _y, one_tile, one_tile, _x, _y, 1, 1, biome_color, 1)
    
    //shader_reset()
  }
  //*/
  
  draw_set_alpha(1)
  surface_reset_target()
  surface_free(surf_temp)
  
  
  
}else{ //if it's an interior cell
  
  if variable_instance_exists(id, "interior_string") &amp;&amp; (interior_string != ""){
    
    //show_debug_message("interior string exists")
    var str = interior_string
    
    //draw the entire floor at once to optimize
      texture_set_repeat(true);
      shader_set(shStretch);
      shader_set_uniform_f(shader_get_uniform(shStretch, "stretch"), 16);
      for (var i = 0; i&lt; 16; i++){
        draw_sprite_ext(spr_dungeon_tiles, 0, 0, i*16, 16, 1, 0, c_white, 1);
      }
      shader_reset();
    
    //draw all the other objects
    for(var i = 0; i &lt; tiles_x; i++){
      for(var j = 0; j &lt; tiles_y; j++){
        var value = obsticals_grid[# i, j]
        if (value = 0) continue;
        draw_sprite(spr_dungeon_tiles, value, i*tile_size, j*tile_size)
      }
    }
  
  }
}

/*
if (show_chunks) {
    //draw chunk boarders
      var chunk_str = "("+string(chunk_x)+","+string(chunk_y)+")";
      draw_set_colour(c_yellow)
      draw_rectangle(0, 0, sprite_width, sprite_height, true)
      draw_set_font(global.font_menu2x)
      draw_text(x+1,y+1,chunk_str)
    }
*/    

surface_reset_target()                
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///clean up the left over noise


texture_set_interpolation(false)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Destroy Self

if should_exist = false{
  if ds_exists(heightmap_grid, ds_type_grid){
    ds_grid_destroy(heightmap_grid)
  }
  
  if variable_instance_exists(id, "terrain_surface"){
    surface_free(terrain_surface)
  }
  
  chunk_forget(chunk_x, chunk_y)
  
  instance_destroy()
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Check for already existing objects in the chunk

objects_in_chunk = false
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///queue up the loading

if (objects_in_chunk = false){
  alarm_set(2,1)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Chunk


//check to see if the chunk is visible
if is_visible(){

  //draw the water first so it's underneath
  if (has_water = true){
    draw_set_alpha(1)
    draw_set_color(c_white)
    
    if (global.chunk_handler.chunk_water_surface_drawn_this_frame = false)
    || !surface_exists(global.chunk_handler.chunk_water_surface)
    {
      //surfaces are destroyed when the window is resized, so recreate it if needed
      if !surface_exists(global.chunk_handler.chunk_water_surface){
        global.chunk_handler.chunk_water_surface = surface_create(global.chunk_handler.chunk_width, global.chunk_handler.chunk_height)
      }
      
      global.chunk_handler.chunk_water_surface_drawn_this_frame = true
      surface_set_target(global.chunk_handler.chunk_water_surface)
      shader_set_displacement(shd_water_displacement);
        draw_sprite_repeat(tile_water, 
                           0, 
                           0,
                           0, 
                           global.chunk_handler.chunk_width, 
                           global.chunk_handler.chunk_height, 
                           0.5);
      texture_set_repeat(false);
      shader_reset();
      surface_reset_target()
      texture_set_interpolation(false);
      
    }
    
    //if the water has already been drawn this frame just re-draw it.
    draw_surface(global.chunk_handler.chunk_water_surface, x, y)
    
  }
  
  
  
  
  
  if (terrain_surface != -1) || surface_exists(terrain_surface){
    draw_set_alpha(1)
    scr_draw_2dig()
    draw_set_alpha(1)
  }
  
  
  if (show_chunks) {
    if is_interior(x,y){
      var array = interior_chunk_find_grid_pos(chunk_x, chunk_y)
      var grid_x = array[0];
      var grid_y = array[1];
      var map = array[2];
      var zone = map[? "zone_pos"];
      var chunk_debug_string = "("+string(grid_x)+","+string(grid_y)+")"+"#Zone = "+string(zone);
    }else{
      var chunk_debug_string = "("+string(chunk_x)+","+string(chunk_y)+")"+"#x = "+string(x)+"#y = "+string(y);
    }
      draw_set_colour(c_yellow)
      draw_set_font(global.font_menu)
      draw_set_valign(fa_top);
      draw_set_halign(fa_left);
      draw_text(x+1, y+1, chunk_debug_string)
      draw_set_colour(c_white)
  }

}


texture_set_interpolation(false)





</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
