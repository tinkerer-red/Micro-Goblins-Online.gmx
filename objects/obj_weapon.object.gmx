<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_weap_test</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>obj_weapon</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///define variable stats
w_name = "Default Weapon"
w_type = item_type_weapon_melee

w_damage = 1
w_knockback = 8
w_size = 1
w_speed = 180/(room_speed * 0.5)  //6 degrees at 60fps
proj_speed = (15*16)/room_speed //4 pixels per frames at 60 fps = 15 tiles per second
w_range = 16 * 20
w_hype = sqrt( power(sprite_height,2) + power(sprite_width,2))
w_spawn_time_out = room_speed / 4


//sprite_index = sprite_index
sprite_proj = sprite_index
sprite_summon_head = sprite_index
sprite_summon_body = sprite_index
anim_attack_timer = 0
//range_weap_timer = 0  //used to stop drawing the weapon after attack since the two arent connected; otherwise the gun would only appear for a single frame
//summon_weap_timer = 0  //used to stop drawing the weapon after attack since the two arent connected; otherwise the gun would only appear for a single frame

start_x = x
start_y = y
w_start_dir = 0
rot = 0
attack_speed = 0 //this is used in the future to calculate


owner_id = -1

attack = true
proj_spawned = 0
//attacking = false
distance_traveled = 0
dis = 9
pre_collide = false
collide = false

//modifier stats
active_queue = -1
weapon_event_queues = -1

//melee mods
stabbing = false //for the multi stab modifier
swiftness = 0
slowness  = 0
melee_ranged = 0
is_chained = false

//ranged mods
is_targeting = false
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init queue variables
recent_proj_queue = -1
proj_queue = -1

self.step_event_queues = -1
self.step_event_queues_temp = -1

self.pre_col_queues = -1
self.pre_col_queues_temp = -1

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>trav_dis_dir = 0
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///clean up left over queues

if variable_instance_exists(id, "active_queue"){
  if active_queue != -1{
    if ds_exists(active_queue, ds_type_priority){
      ds_priority_destroy(active_queue)
      active_queue = -1
    }
  }
}

if variable_instance_exists(id, "recent_proj_queue"){
  if recent_proj_queue != -1{
    if ds_exists(recent_proj_queue, ds_type_queue){
      ds_queue_destroy(recent_proj_queue)
      recent_proj_queue = -1
    }
  }
}

if variable_instance_exists(id, "proj_queue"){
  if proj_queue != -1{
    if ds_exists(proj_queue, ds_type_queue){
      ds_queue_destroy(proj_queue)
      proj_queue = -1
    }
  }
}

if variable_instance_exists(id, "weapon_event_queues"){
  if weapon_event_queues != -1{
    if ds_exists(weapon_event_queues, ds_type_priority){
      ds_priority_destroy(weapon_event_queues)
      weapon_event_queues = -1
    }
  }
}

if variable_instance_exists(id, "mod_ranged_start"){
  if ds_exists(proj_weapon_event_queues, ds_type_priority){
    ds_priority_destroy(proj_weapon_event_queues)
    proj_weapon_event_queues = -1
  }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Double Strike mod

var echo_inst;

self.echo_inst = instance_copy(false)
self.echo_inst.w_start_dir = self.w_start_dir
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///annimate weapon / spawn melee proj

if (weapon_event_queues != -1){


//we put this at the top to ensure an exta frame of animation for the extremely fast melee weapons.
if !variable_instance_exists(self.id, "anim_attack_start") {anim_attack_start = true}
//set the animation variables
if (anim_attack_start){
  anim_attack_start = false;
  
  var speed_mods = slowness - swiftness
  
  // anim_time is used to equate exactly how many frames the animation needs to take
  anim_attack_time = ceil(owner_id.active_w_spawn_time_out * ((0.01*power(speed_mods,2)) + (0.15*speed_mods) + 1))
  anim_attack_timer = anim_attack_time
  
  // lastly max_-_multiplier is the maximum distance we want the axis to move, the cos/sin function would move it a parcent of the max
  anim_attack_max_direction_multiplier = 180
  
  // this variable is only used to make sure we only calculate the animation's variables once
  anim_attack_start = false
  
  //show_debug_message("dis = "+string(dis))
}




if (w_type = item_type_weapon_melee)
{
  //if no animation modifiers, then run defult single stab anim
  
  // reset values for ideal location (so modifiers can calculate new locations on their own)
  if (!variable_instance_exists(self, "mod_delay_start")){
    x = self.owner_id.x + lengthdir_x(dis, w_start_dir);
    y = self.owner_id.y + lengthdir_y(dis, w_start_dir);
    direction = w_start_dir;
    image_angle = direction-45;
  }
  
  ///if attack is finished
  if (anim_attack_timer &lt;= 0)
  {
    self.owner_id.player_state = e_player_state.attack
    self.owner_id.attack = false
    self.owner_id.post_attack = true
    
    if ds_exists(weapon_event_queues, ds_type_priority)
    {
      //show_debug_message("weapon finished")
      ds_priority_destroy(weapon_event_queues)
      weapon_event_queues = -1
    }
    
    //self.pre_collide = true
    instance_destroy()
  }
  
  anim_attack_timer -= 1*lag()
  
}





if (w_type = item_type_weapon_range) &amp;&amp; (self.attack = false)
{
  show_debug_player(0 , "anim_attack_timer = "+string(anim_attack_timer))
  anim_attack_timer -= 1*lag()
  if (anim_attack_timer &lt;= 0)
  {
    self.owner_id.player_state = e_player_state.attack
    self.owner_id.attack = false
    self.owner_id.post_attack = true
  }
}



if (w_type = item_type_weapon_summon) &amp;&amp; (self.attack = false)
{
  anim_attack_timer -= 1*lag()
  if (anim_attack_timer &lt;= 0)
  {
    self.owner_id.player_state = e_player_state.attack
    self.owner_id.attack = false
    self.owner_id.post_attack = true
  }
}


}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Attack step event
if (weapon_event_queues != -1){
////////////////////////////////////////////////////////////////////
//Attack step event
////////////////////////////////////////////////////////////////////
if !self.attack &amp;&amp; !self.collide &amp;&amp; !self.pre_collide  //if spawning projectiles
{
  //show_debug_message("weap - Attack step event")
  
  if !ds_exists(self.step_event_queues, ds_type_priority)
  {
    self.step_event_queues = ds_priority_create()
    ds_priority_copy(self.step_event_queues, ds_priority_delete_min(self.weapon_event_queues))
  }
  
  //dont delete the queue untill the collision actually happens
  //so instead we make a copy to deal with
  if !ds_exists(self.step_event_queues_temp, ds_type_priority)
  {
    self.step_event_queues_temp = ds_priority_create()
    ds_priority_copy(self.step_event_queues_temp, self.step_event_queues)
  }
  
  //check to see if there is even anything in the step queue
  if !ds_priority_empty(self.step_event_queues){
    
    while !ds_priority_empty(self.step_event_queues_temp)
    {
      scr = script_execute(ds_priority_delete_min(self.step_event_queues_temp))
    }
    
    if ds_priority_empty(self.step_event_queues_temp)
    {
      ds_priority_copy(self.step_event_queues_temp, self.step_event_queues)
    }
  }
  
  //ds_priority_delete_min(weapon_event_queues)
  //dont delete the queue untill the collision actually happens
  
  //var self.result = scr_run_modifiers() //pre collision modifiers
  //if self.result = true
  //{
  //  
  //}
  
  //if (distance_to_point(start_x, start_y) &gt;= w_range)
  //{
  //  self.pre_collide = true
  //}
  if place_meeting(x,y, obj_entity){
    var enemy = nearest_enemy(x, y, w_hype)
    if (enemy != noone)
    {
      if (enemy.invulnerable = false){
        deal_damage(enemy, w_damage)
        
        enemy.spd = self.w_knockback
        enemy.direction = direction
      }
    }
  }
}


}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Projectile/Summon spawn modifiers

if (weapon_event_queues != -1){
////////////////////////////////////////////////////////////////////
//Projectile/Summon spawn modifiers
////////////////////////////////////////////////////////////////////



  ////////////////////
  ///// Melee Ranged
  ////////////////////
  if (w_type = item_type_weapon_melee) &amp;&amp; ((melee_ranged &gt; 0) &amp;&amp; (proj_spawned &lt; melee_ranged))
  {
    var anim_timer_iterations = anim_attack_time / (melee_ranged+1)
    
    //if the timer is on a projectile iteration greater then the number of projectiles spawned then we can spawn the new projectile
    if ((anim_attack_time-anim_attack_timer) div anim_timer_iterations &gt; proj_spawned)
    {
      proj_spawned += 1
      
      var distance = ((self.sprite_width*self.image_xscale)/2 + (self.sprite_height*self.image_yscale)/2) /2 +1
      var xx = x+lengthdir_x(distance, self.direction);
      var yy = y+lengthdir_y(distance, self.direction);
      
      //we store them in a queue so all modifiers can deal with all bullets
      self.recent_proj_queue = ds_queue_create()
      
      var proj = instance_create(xx, yy, obj_weap_proj);
      
      proj.direction = direction
      proj.owner_weap = id
      proj.owner_id = owner_id
      
      /// init the new projectile ignoring proj spawn modifiers since these shouldnt be on there at all
      proj.weapon_event_queues = ds_priority_create()
      ds_priority_copy(proj.weapon_event_queues, proj_weapon_event_queues)
      
      //the variable "proj_weapon_event_queues" was made by the ranged modifier at init
      
      proj.image_angle = proj.direction-45
      
      proj.sprite_index = sprite_proj
      proj.w_hype = fast_hype(proj.sprite_height, proj.sprite_width)
      //if (proj.sprite_index = sprite_index) {proj.image_angle -= 45}
      
      proj.image_xscale = w_size
      proj.image_yscale = w_size
      
      proj.owner_id = owner_id
      
      proj.start_x = proj.x
      proj.start_y = proj.y
      
      proj.w_damage = w_damage
      //proj.w_range = w_range
      proj.w_knockback = w_knockback
      proj.speed = self.proj_speed //w_speed
      
      proj.projectile_active = true
    }
  }
  
  
    
      
  
  

if self.attack  //if spawning projectiles
{
  //show_debug_message("weap - Projectile spawn modifiers")
  ////////////////////
  ///// Ranged
  ////////////////////
  if ((w_type = item_type_weapon_range) &amp;&amp; (proj_spawned = 0))
  {
    proj_spawned += 1
    
    var distance = ((self.sprite_width*self.image_xscale)/2 + (self.sprite_height*self.image_yscale)/2) /2 +1
    var xx = x+lengthdir_x(distance, self.direction);
    var yy = y+lengthdir_y(distance, self.direction);
    
    //we store them in a queue so all modifiers can deal with all bullets
    self.recent_proj_queue = ds_queue_create()
    
    var proj = instance_create(xx, yy, obj_weap_proj);
    
    proj.direction = direction
    proj.owner_weap = id
    proj.owner_id = owner_id
    
    ds_queue_enqueue(self.recent_proj_queue, proj)
    //we also create a full queue to give these projectiles their step events in the next code block
    self.proj_queue = ds_queue_create()
    
    //copy the OG bullet into the queue because mod scripts will handle their spawned projetiles on their own
    ds_queue_copy(self.proj_queue, self.recent_proj_queue)
    
  }
  
  ////////////////////
  ///// Summon
  ////////////////////
  if (w_type = item_type_weapon_summon)
  {
    var distance = ((self.sprite_width*self.image_xscale)/2 + (self.sprite_height*self.image_yscale)/2) /2 +1
    var xx = x+lengthdir_x(distance, self.direction);
    var yy = y+lengthdir_y(distance, self.direction);
    
    //we store them in a queue so all modifiers can deal with all summons
    self.recent_summon_queue = ds_queue_create()
    
    var self.summon = instance_create(xx, yy, obj_summon)
    self.summon.direction = direction
    
    ds_queue_enqueue(self.recent_summon_queue, self.summon)
    //we also create a full queue to give these summons their step events in the next code block
    self.summon_queue = ds_queue_create()
    
    //copy the OG summon into the queue because mod scripts will handle their spawned summons on their own
    ds_queue_copy(self.summon_queue, self.recent_summon_queue)
  }
  
  
  ///////////////
  var self.result = scr_run_modifiers() //projectile spawn modifiers
  ///////////////
  
  if self.result = true
  {
    ////////////////////
    ///// Ranged
    ////////////////////
    if (w_type = item_type_weapon_range)
    {
      ds_queue_destroy(self.recent_proj_queue)
      recent_proj_queue = -1
      
      //init projectiles
      while !ds_queue_empty(self.proj_queue){
        var proj = ds_queue_dequeue(self.proj_queue);
        if instance_exists(proj){
          init_projectile(proj)
        }
      }
      
      ds_queue_destroy(self.proj_queue)
      proj_queue = -1
    }
    
    
    
    ////////////////////
    ///// Summon
    ////////////////////
    if (w_type = item_type_weapon_summon)
    {
      ds_queue_destroy(self.recent_summon_queue)
      recent_summon_queue = -1
      
      while !ds_queue_empty(self.summon_queue)
      {
        var summon = ds_queue_dequeue(self.summon_queue);
        
        //copy the last of the queues to the summon
        summon.weapon_event_queues = ds_priority_create()
        ds_priority_copy(summon.weapon_event_queues, self.weapon_event_queues)
        
        summon.is_summoned = true;
        summon.owner_id = owner_id
        summon.enemy = nearest_enemy(x, y, 16*20)
        
        //summon.direction = direction
        summon.image_angle = summon.direction-45
        
        summon.sprite_summon_head = sprite_summon_head
        summon.sprite_summon_body = sprite_summon_body
        
        summon.sprite_index = spr_green
        //if (summon.sprite_index = sprite_index) {summon.image_angle -= 45}
        
        summon.image_xscale = w_size
        summon.image_yscale = w_size
        
        
        summon.start_x = summon.x
        summon.start_y = summon.y
        
        summon.e_damage = w_damage
        summon.e_range = w_range
        summon.e_knockback = w_knockback
      }
      ds_queue_destroy(self.summon_queue)
      summon_queue = -1
      
      //if (w_type = item_type_weapon_summon){
        //self.owner_id.attack = false
        //self.owner_id.post_attack = true
        //draw_self()
        //instance_destroy()
      //}
    }
    
    self.attack = false
    
  }
}



}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Pre collision modifiers
if (weapon_event_queues != -1){
////////////////////////////////////////////////////////////////////
//Pre collision modifiers
////////////////////////////////////////////////////////////////////
if !self.attack &amp;&amp; !self.collide &amp;&amp; self.pre_collide //if collision is detected, before collision is for sure
{
  //show_debug_message("weap - Pre collision modifiers")
  
  var self.result = scr_run_modifiers() //pre collision modifiers like boomerange
  if self.result = true
  {
    self.attack = false
  }
}



}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///collision modifiers
if (weapon_event_queues != -1){
////////////////////////////////////////////////////////////////////
//collision modifiers
////////////////////////////////////////////////////////////////////
if !self.attack &amp;&amp; self.collide  //if officially collided
{
  //show_debug_message("weap - collision modifiers")
  var self.result = scr_run_modifiers() //collision modifiers
  if self.result = true
  {
    self.attack = false
  }
}

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw modifiers

// if the weapon in chained, draw the chain
if (is_chained){
  //for now we're just going to draw a line to player center
    //draw_line_colour(x, y, owner_id.x, owner_id.y, c_black, c_black)
  //not any more bitch!
  draw_sprite_line_shader(spr_chain, 0, x, y, owner_id.x, owner_id.y)
}

// if the weapon is targeting draw the target
shader_set_hue(owner_id.fav_hue)
if is_targeting{
  draw_sprite(spr_target, 0, mod_targeting_target_x, mod_targeting_target_y)
}
shader_reset()

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw self
shader_set_hue(owner_id.fav_hue)
draw_self()
shader_reset();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
