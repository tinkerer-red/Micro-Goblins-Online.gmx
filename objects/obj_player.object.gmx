<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprite9</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_entity</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///set player number

if (htme_isLocal())
{
  if (variable_global_exists("numberOfLocalPlayers") = false) || (variable_global_exists("numberOfLocalPlayers") = undefined)
  {
    player_id_local = 0
    global.numberOfLocalPlayers = 1
  }
  else
  {
    player_id_local = global.numberOfLocalPlayers
    global.numberOfLocalPlayers++
  }
}else{
player_id_local = -1
}


if (variable_global_exists("numberOfGlobalPlayers") = false) || (variable_global_exists("numberOfGlobalPlayers") = undefined)
{
  player_id_global = 0
  global.numberOfGlobalPlayers = 1
}
else
{
  player_id_global = global.numberOfGlobalPlayers
  global.numberOfGlobalPlayers = instance_count
}

//show_debug_message("player id = "+string(player_id))
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///define player variables

//stats
e_health = 30

//movement stuff
self.acceleration = 0.25
self.max_speed = 2
self.spd = 0
self.dir = 90
self.speed = 0
self.hspeed = 0
self.vspeed = 0
self.friction = 0.0
xpreviousframe = x
ypreviousframe = y
in_interior = false

//animation stuff
anim_rot_active = false
facing = 1

//weapon stuff
weap_num_old = -1
weap_inst = -1
item_used_check = -1
weap_num = -1
attack = false
attacking = false
post_attack = false

///Modifier variables
for (var i = 0; i &lt;= 6; i++){
  item_mods[i] = -1
}
for (var i = 0; i &lt; 3; i++){
  
  cooldown_array[0, i] = true
  //timer
  cooldown_array[1, i] = 0
}

mod_queue = -1
active_queue = -1
weapon_event_queues = -1
weap_queue = -1

//global modifiers variable
repeater_in_queue = false
mod_charge_timer = 0

//melee mod varible
mod_dash_frame = 0
mod_evade_frame = 0

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///define player states

enum e_player_state{
  move,
  attack,
};

self.player_state = e_player_state.move

enum e_player_anim{
  idle,
  walk,
  rot,
  dmg,
};

self.player_anim_state = e_player_anim.idle
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Controls set to false
self.up    = 0
self.down  = 0
self.left  = 0
self.right = 0

self.item_a = 0
self.item_b = 0
self.item_c = 0
self.item_a_pressed = 0
self.item_b_pressed = 0
self.item_c_pressed = 0
self.action = 0
self.action_pressed = 0

self.zoom_in_pressed = 0
self.zoom_out_pressed = 0

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///[TEMP] Create the weapon queues for equiment

///when equiping

for (var i = 0; i &lt; 3; i++)
{
  self.item_data[i, weapon_name] = "Sword of Testing"
  
  if (i = 0) self.item_data[i, weapon_type] = item_type_weapon_range
  if (i = 1) self.item_data[i, weapon_type] = item_type_weapon_melee
  if (i = 2) self.item_data[i, weapon_type] = item_type_weapon_summon
  
  self.item_data[i, weapon_sprite] = spr_weap_test
  self.item_data[i, weapon_proj_sprite] = spr_weap_test
  self.item_data[i, weapon_aoe_sprite] = spr_aoe_runic
  
  self.item_queues[i] = ds_priority_create()
  
  var queue_button_mods = ds_priority_create()
  var queue_pre_weap_mods = ds_priority_create()
  var queue_weap_spawn_mods = ds_priority_create()
  var queue_proj_spawn_mods = ds_priority_create()
  var queue_attack_step_mods = ds_priority_create()
  var queue_pre_col_mods = ds_priority_create()
  var queue_col_mods = ds_priority_create()
  var queue_post_attack_mods = ds_priority_create()
  
  
  //player mods
  ds_priority_add(item_queues[i], queue_button_mods, 1);
  ds_priority_add(item_queues[i], queue_pre_weap_mods, 2);
  ds_priority_add(item_queues[i], queue_weap_spawn_mods, 3);
  //weapon's mods
  ds_priority_add(item_queues[i], queue_proj_spawn_mods, 4);
  ds_priority_add(item_queues[i], queue_attack_step_mods, 5);
  ds_priority_add(item_queues[i], queue_pre_col_mods, 6);
  ds_priority_add(item_queues[i], queue_col_mods, 7);
  //player mods after the weapon
  ds_priority_add(item_queues[i], queue_post_attack_mods, 8);
  
  
  
  ///////////////////////////////////////////////////////////////////////////
  repeat( 0 ) ds_priority_add(queue_button_mods, scr_mod_charged, 1);
  repeat( 0 ) ds_priority_add(queue_button_mods, scr_mod_repeater, 2);
  repeat( 0 ) ds_priority_add(queue_button_mods, scr_1, 3);
  ///////////////////////////////////////////////////////////////////////////
  repeat( 0 ) ds_priority_add(queue_pre_weap_mods, scr_mod_dash, 1);
  repeat( 0 ) ds_priority_add(queue_pre_weap_mods, scr_2, 2);
  ///////////////////////////////////////////////////////////////////////////
  repeat( 0 ) ds_priority_add(queue_weap_spawn_mods, scr_mod_backStab, 1);
  repeat( 0 ) ds_priority_add(queue_weap_spawn_mods, scr_mod_swiftness, 2);
  repeat( 0 ) ds_priority_add(queue_weap_spawn_mods, scr_mod_slowness, 3);
  repeat( 0 ) ds_priority_add(queue_weap_spawn_mods, scr_mod_knockback, 4);
  repeat( 0 ) ds_priority_add(queue_weap_spawn_mods, scr_mod_chained, 5);
  repeat( 0 ) ds_priority_add(queue_weap_spawn_mods, scr_mod_enlarge, 6);
  repeat( 0 ) ds_priority_add(queue_weap_spawn_mods, scr_mod_shrink, 7);
  repeat( 0 ) ds_priority_add(queue_weap_spawn_mods, scr_mod_range, 8);
  repeat( 0 ) ds_priority_add(queue_weap_spawn_mods, scr_3, 1);
  ///////////////////////////////////////////////////////////////////////////
  repeat( 0 ) ds_priority_add(queue_proj_spawn_mods, scr_mod_tractorBeam, 1);
  repeat( 0 ) ds_priority_add(queue_proj_spawn_mods, scr_mod_targeting, 1);
  repeat( 0 ) ds_priority_add(queue_proj_spawn_mods, scr_mod_bonusShot, 2);
  repeat( 0 ) ds_priority_add(queue_proj_spawn_mods, scr_mod_mirrorShot, 3);
  repeat( 0 ) ds_priority_add(queue_proj_spawn_mods, scr_mod_multishot, 4);
  repeat( 0 ) ds_priority_add(queue_proj_spawn_mods, scr_mod_burst, 5);
  repeat( 0 ) ds_priority_add(queue_proj_spawn_mods, scr_mod_inaccurate, 98);
  repeat( 0 ) ds_priority_add(queue_proj_spawn_mods, scr_mod_airStrike, 99);
  repeat( 0 ) ds_priority_add(queue_proj_spawn_mods, scr_4, 1);
  ///////////////////////////////////////////////////////////////////////////
  repeat( 0 ) ds_priority_add(queue_attack_step_mods, scr_mod_delay, 0);
  repeat( 0 ) ds_priority_add(queue_attack_step_mods, scr_mod_slash, 2);
  repeat( 0 ) ds_priority_add(queue_attack_step_mods, scr_mod_thrust, 3);
  repeat( 0 ) ds_priority_add(queue_attack_step_mods, scr_mod_seeking, 4);
  repeat( 0 ) ds_priority_add(queue_attack_step_mods, scr_mod_guiding, 5);
  repeat( 0 ) ds_priority_add(queue_attack_step_mods, scr_mod_flail, 6);
  repeat( 0 ) ds_priority_add(queue_attack_step_mods, scr_mod_moveable, 7);
  repeat( 0 ) ds_priority_add(queue_attack_step_mods, scr_mod_extend, 99);
  
  repeat( 0 ) ds_priority_add(queue_attack_step_mods, scr_mod_summon_movement_walk, 4);
  
  repeat( 0 ) ds_priority_add(queue_attack_step_mods, scr_5, 1);
  ///////////////////////////////////////////////////////////////////////////
  repeat( 0 ) ds_priority_add(queue_pre_col_mods, scr_mod_ricochet, 1);
  repeat( 0 ) ds_priority_add(queue_pre_col_mods, scr_mod_boomerang, 2);
  repeat( 0 ) ds_priority_add(queue_pre_col_mods, scr_mod_cluster, 3);
  repeat( 0 ) ds_priority_add(queue_pre_col_mods, scr_6, 3);
  ///////////////////////////////////////////////////////////////////////////
  repeat( 0 ) ds_priority_add(queue_col_mods, scr_mod_negarang, 1);
  repeat( 0 ) ds_priority_add(queue_col_mods, scr_mod_sticky, 1);
  repeat( 0 ) ds_priority_add(queue_col_mods, scr_mod_continuous, 1);
  repeat( 0 ) ds_priority_add(queue_col_mods, scr_mod_aoe, 2);
  repeat( 0 ) ds_priority_add(queue_col_mods, scr_7, 2);
  ///////////////////////////////////////////////////////////////////////////
  repeat( 0 ) ds_priority_add(queue_post_attack_mods, scr_mod_evade, 1);
  repeat( 0 ) ds_priority_add(queue_post_attack_mods, scr_8, 1);
  ///////////////////////////////////////////////////////////////////////////
  
}



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Netcode //buffer_f16 isn't supported
















/***************************************************
  buffer_f16 IS NOT SUPPORTED!
 ***************************************************/















self.player_name = "Test-icle"
self.fav_hue = 0


if(variable_global_exists("htme_object"))
{
///Network Code

//Update Server
mp_sync()
mp_addPosition("Pos", 5*room_speed)
mp_setType("Pos", mp_type.SMART)
mp_tolerance("Pos", 8)


//add gamemaker stuff
mp_addBuiltinBasic("basicDrawing", 15*room_speed)
mp_setType("basicDrawing", mp_type.SMART)

//add physics here if you need it in the future
mp_addBuiltinPhysics("physics", 15*room_speed)
mp_setType("physics", mp_type.SMART)


//add variables
mp_add("playerName", "player_name", buffer_string, 3*room_speed)
mp_setType("playerName",mp_type.SMART)

//buffer_f16 isn't supported
//add controls
mp_add("controls", "up,down,left,right,item_a,item_b,item_c,item_a_pressed,item_b_pressed,item_c_pressed", buffer_f32, 1) //buffer_f16 isn't supported
mp_setType("controls",mp_type.FAST)

//add Item maps
//mp_add("item_maps", "item_a_map,item_b_map,item_c_map", buffer_string, 1)
//mp_add("item_maps", "item_a_map,item_b_map,item_c_map,item_a_prior,item_b_prior,item_c_prior", buffer_string, 1)
//mp_add("item_maps", "item_a_map,item_b_map,item_c_map,armor_head_map,armor_body_map,armor_boggle_map", buffer_string, room_speed)

//lets try un grouping the itmes
mp_add("item_a", "item_a_map,item_a_prior", buffer_string, 1)
mp_add("item_b", "item_b_map,item_b_prior", buffer_string, 1)
mp_add("item_c", "item_c_map,item_c_prior", buffer_string, 1)

mp_add("fav_hsv", "fav_hue", buffer_f32, room_speed)


//RE ADD THIS WHEN ARMOR EXISTS
//mp_add("item_maps", "item_a_map,item_b_map,item_c_map,armor_head_map,armor_body_map,armor_boggle_map", buffer_string, 1)
mp_setType("item_maps",mp_type.SMART)

//store a dummy version of the map to prevent crashing
last_encoded_equipment = encode_equipment();

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///REMOVE THIS

ani = false

circle_size = 0
radius_i = 1
rect_left   = 0;
rect_right  = 0;
rect_top    = 0;
rect_bottom = 0;

wall_dir = 0

_x1=0
_x2=0
_y1=0
_y2=0

//image_xscale = 4
//image_yscale = 2
trav = sprite_width*sprite_height
debug = false
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Define Outfit

head = spr_head_template;
body = spr_body_template;
fav_hue = 0; //default hue is red
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sync information from the server
if (!htme_isLocal())
{
  if(variable_global_exists("htme_object"))
  {
    self.name = mp_map_syncOut("player_name", name)
    self.fav_hue = mp_map_syncOut("fav_hue", fav_hue)
    self.up = mp_map_syncOut("up", up)
    self.down = mp_map_syncOut("down", down)
    self.left = mp_map_syncOut("left", left)
    self.right = mp_map_syncOut("right", right)
    self.item_a = mp_map_syncOut("item_a", item_a)
    self.item_b = mp_map_syncOut("item_b", item_b)
    self.item_c = mp_map_syncOut("item_c", item_c)
    self.action = mp_map_syncOut("action",self.action)
    self.item_a_pressed = mp_map_syncOut("item_a_pressed", item_a_pressed)
    self.item_b_pressed = mp_map_syncOut("item_b_pressed", item_b_pressed)
    self.item_c_pressed = mp_map_syncOut("item_c_pressed", item_c_pressed)
    self.action_pressed = mp_map_syncOut("action_pressed",self.action_pressed)
    //player_state = mp_map_syncOut("player_state", player_state)
    
    //sync equipment
    //new_encoded_equipment;
    /*
    if (is_undefined(last_encoded_equipment)) {
      last_encoded_equipment = encode_equipment()
      show_debug_message("encoded in end step")
    }
    */
    var array;
    array[0] = mp_map_syncOut("item_a_map", last_encoded_equipment[0])
    array[1] = mp_map_syncOut("item_b_map", last_encoded_equipment[1])
    array[2] = mp_map_syncOut("item_c_map", last_encoded_equipment[2])
    array[6] = mp_map_syncOut("item_a_prior", last_encoded_equipment[6])
    array[7] = mp_map_syncOut("item_b_prior", last_encoded_equipment[7])
    array[8] = mp_map_syncOut("item_c_prior", last_encoded_equipment[8])
    //array[3] = mp_map_syncOut("armor_head_map", last_encoded_equipment[3])
    //array[4] = mp_map_syncOut("armor_body_map", last_encoded_equipment[4])
    //array[5] = mp_map_syncOut("armor_boggle_map", last_encoded_equipment[5])
    //array[9] = mp_map_syncOut("armor_head_prior", last_encoded_equipment[9])
    //array[10] = mp_map_syncOut("armor_body_prior", last_encoded_equipment[10])
    //array[11] = mp_map_syncOut("armor_boggle_prior", last_encoded_equipment[11])
    decode_equipment(array);
   
    
    
    //also update the player sprite
    switch (string_lower(self.name))
    {
    case "red":
      head = spr_head_dev_skin_head_red;
      body = spr_head_dev_skin_body_red;
      break;
    case "arma":
    case "armadillo":
      head = spr_head_template;
      body = spr_body_template;
      break;
    case "olaf":
      head = spr_head_dev_skin_head_olaf;
      body = spr_head_dev_skin_body_olaf;
      break;
    case "shiv":
    case "shaymire":
      head = spr_head_dev_skin_head_shaymire;
      body = spr_head_dev_skin_body_shaymire;
      break;
    case "nostud thiago":
      head = spr_head_dev_skin_head_nostud_thiago;
      body = spr_head_dev_skin_body_nostud_thiago;
      break;
    default:
      head = spr_head_template;
      body = spr_body_template;
    } 
  }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Animation handler

if (spd = 0){
  self.player_anim_state = e_player_anim.idle
}


if (self.player_anim_state &lt;= e_player_anim.walk){
  if spd &gt; 0{// if damaged activate damaged step
    if self.player_anim_state = e_player_anim.idle{
      anim_time = 0
      anim_timer = 0
      anim_flip_frame = 0
      anim_travel_dis = 0
      pi_time = 0
      view_loop = 9
      max_y_multiplier = 0
      max_x_multiplier = 0
    }
    self.player_anim_state = e_player_anim.walk
  }
}

  
    
if (self.player_anim_state &lt;= e_player_anim.rot){
  //incase we're moving directly vertical, and we're still turning this check will fix the bug
  if (anim_rot_active = true) self.player_anim_state = e_player_anim.rot;
  
  //if moving right
  if (abs(angle_difference(direction, 0)) &lt; 70){
    if (facing = -1) || (image_xscale &lt; 0){
      //this check is to make sure we dunt update the facing direction while we're rotating
      if (anim_rot_active = false) facing = 1;
      anim_rot_active = true
      self.player_anim_state = e_player_anim.rot
    }
  }
  
  //if moving left
  if (abs(angle_difference(direction, 180)) &lt; 70){
    if (facing = 1) || (image_xscale &gt; 0){
      //this check is to make sure we dunt update the facing direction while we're rotating
      if (anim_rot_active = false) facing = -1;
      anim_rot_active = true
      self.player_anim_state = e_player_anim.rot
    }
  }
}


  
if self.player_anim_state &lt;= e_player_anim.dmg{
  if false{// if damaged activte damaged step
    self.player_anim_state = e_player_anim.dmg
  }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///previous frame x,y

xpreviousframe = x
ypreviousframe = y


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///debug

show_debug_player("spd = "+string(spd))
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sync information to the server's map



if (htme_isLocal())
{
  ///this is where you store your variables that should be sent to server
  scr_control_handler(player_id_local)
}
  
  if(variable_global_exists("htme_object"))
  {
    mp_map_syncIn("player_name",self.name)
    mp_map_syncIn("fav_hue",self.fav_hue)
    mp_map_syncIn("up",self.up)
    mp_map_syncIn("down",self.down)
    mp_map_syncIn("left",self.left)
    mp_map_syncIn("right",self.right)
    mp_map_syncIn("item_a",self.item_a)
    mp_map_syncIn("item_b",self.item_b)
    mp_map_syncIn("item_c",self.item_c)
    mp_map_syncIn("action",self.action)
    mp_map_syncIn("item_a_pressed",self.item_a_pressed)
    mp_map_syncIn("item_b_pressed",self.item_b_pressed)
    mp_map_syncIn("item_c_pressed",self.item_c_pressed)
    mp_map_syncIn("action_pressed",self.action_pressed)
    //mp_map_syncIn("player_state",player_state)
    
    //sync equipment
    if (htme_isLocal()){
      self.last_encoded_equipment = encode_equipment();
      
      mp_map_syncIn("item_a_map",self.last_encoded_equipment[0])
      mp_map_syncIn("item_b_map",self.last_encoded_equipment[1])
      mp_map_syncIn("item_c_map",self.last_encoded_equipment[2])
      mp_map_syncIn("item_a_prior",self.last_encoded_equipment[6])
      mp_map_syncIn("item_b_prior",self.last_encoded_equipment[7])
      mp_map_syncIn("item_c_prior",self.last_encoded_equipment[8])
      //mp_map_syncIn("armor_head_map",array[3])
      //mp_map_syncIn("armor_body_map",array[4])
      //mp_map_syncIn("armor_boggle_map",array[5])
      //mp_map_syncIn("armor_head_prior",array[9])
      //mp_map_syncIn("armor_body_prior",array[10])
      //mp_map_syncIn("armor_boggle_prior",array[11])
      
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///player state handler


if (self.player_state = e_player_state.move)
{
  scr_player_state_move_input()
  
}

scr_player_state_move()
//show_debug_player(self.player_id_local, "spd = "+string(spd))



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Cooldown timers

for (var i = 0; i &lt; 3; i++)
{
  //show_debug_message("cooldown_array[1, "+string(i)+"] = "+string(cooldown_array[1, i]))
  if (self.cooldown_array[1, i] != 0)
  {
    self.cooldown_array[1, i] -= 1
  
    if (self.cooldown_array[1, i] &lt;= 0)
    {
      //show_debug_message("SET TO TRUE")
      self.cooldown_array[0, i] = true
      self.cooldown_array[1, i] = 0
    }else{
      //show_debug_message("SET TO FALSE")
      self.cooldown_array[0, i] = false
    }
  }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///[Modifier] Button Queue / Attack Start
//show_debug_message("item_used_check = "+string(item_used_check))



///////////////////////////
//Melee weapon cancel check
///////////////////////////
if (!is_jocky) &amp;&amp; (self.item_a_pressed || self.item_b_pressed || self.item_c_pressed)
{
  if (self.weap_num &gt;= 0) &amp;&amp; (self.player_state = e_player_state.attack)
  {
    if (self.item_data[self.weap_num, weapon_type] = item_type_weapon_melee)
    {
      if ds_exists(self.weapon_event_queues, ds_type_priority){
        ds_priority_destroy(self.weapon_event_queues)
      }
      if ds_exists(self.active_queue, ds_type_priority){
        ds_priority_destroy(self.active_queue)
      }
      self.weapon_event_queues = -1
      self.active_queue = -1
      self.repeater_in_queue = false
      self.attack = false
      self.post_attack = false
      self.player_state = e_player_state.move
      
      //destroy previous weapons
      if ds_exists(self.weap_queue, ds_type_queue){
        while !ds_queue_empty(self.weap_queue){
          var weap_inst = ds_queue_dequeue(self.weap_queue)
          if instance_exists(weap_inst) &amp;&amp; (weap_inst != -1){
            if (weap_inst.object_index = obj_weapon) {
              ds_priority_destroy(weap_inst.weapon_event_queues)
              weap_inst.weapon_event_queues = -1
            
              instance_destroy(weap_inst)
            }
              weap_inst = -1
          }
        }
      }
      
      
      //show_debug_message("melee attack canceled")
      self.item_used_check = -1
      
      ///reset player based variables which were applied by modifiers
      self.mod_charge_timer = 0
      mod_dash_start = false
      mod_evade_start = false
    }
  }
}





////////////////////////////////////////////////////////////////////
//Button Queue
////////////////////////////////////////////////////////////////////

if (!is_jocky) &amp;&amp; (self.player_state = e_player_state.move)
{
  if (self.item_a || self.item_b || self.item_c) || (self.mod_charge_timer &gt;= room_speed)
  {
    self.weap_num_old = self.weap_num
    
    ///this gross if section will need to be replaced with a method in the future to check to see if the weapon's cool down if finished, and if not check the next item (incase multiple buttons are pressed at once)
    if self.item_c {self.weap_num = 2}
    if self.item_b {self.weap_num = 1}
    if self.item_a {self.weap_num = 0}
    
    
    //if the button was changed while charging
    if (self.weap_num_old != self.weap_num) &amp;&amp; (self.weap_num_old != -1)
    {
      if ds_exists(self.active_queue, ds_type_priority)
      {
        //show_debug_message("first destroy")
        
        ds_priority_destroy(self.weapon_event_queues)
        ds_priority_destroy(self.active_queue)
        
        self.weapon_event_queues = -1
        self.active_queue = -1
        self.repeater_in_queue = false
        //destroy previous weapons
        if ds_exists(self.weap_queue, ds_type_queue){
          while !ds_queue_empty(self.weap_queue){
            var weap_inst = ds_queue_dequeue(self.weap_queue)
            if instance_exists(weap_inst) &amp;&amp; (weap_inst != -1){
              if (weap_inst.object_index = obj_weapon) {
                ds_priority_destroy(weap_inst.weapon_event_queues)
                weap_inst.weapon_event_queues = -1
              
                instance_destroy(weap_inst)
              }
                weap_inst = -1
            }
          }
        }
        
      }
      
      //show_debug_message("the button was changed while charging")
      self.item_used_check = -1
      
      self.mod_charge_timer = 0
    }
    
    
    
    ///////////////////////////////////////////////////////
    // create the active weapon queues from the queue array
    ///////////////////////////////////////////////////////
    if !ds_exists(self.active_queue, ds_type_priority)// || new_queue
    {
      self.weapon_event_queues = ds_priority_create() //make sure to delete after the projectile inherits
      
      ds_priority_copy(self.weapon_event_queues, self.item_queues[weap_num]) // should return queue_item_event_queues for the item
      
      var self.step_queue = ds_priority_delete_min(self.weapon_event_queues) //the button queue will be in there even if nothing is in the button queue its self
      //show_debug_message("creating the data")
      
      self.active_queue = ds_priority_create()
      ds_priority_copy(self.active_queue, self.step_queue);
      
      
      if (ds_priority_find_priority(self.active_queue, scr_mod_repeater) != undefined){
        self.repeater_in_queue = true
      }else{
        self.repeater_in_queue = false
      }
      
      
      /// Cool Downs
      self.active_w_cooldown = room_speed/3
      self.active_w_spawn_time_out = room_speed/2
      
      self.active_w_damage = 1
      
      
      self.active_w_knockback = 4
    }
    
    
    //////////////////////////////////////////////////
    /// log the button queue into the currently active queue
    //////////////////////////////////////////////////
    if (self.cooldown_array[0, self.weap_num]) &amp;&amp; ((self.item_used_check != self.weap_num) || (self.repeater_in_queue))
    {
    
      if ds_exists(self.active_queue, ds_type_priority)
      {
        if !ds_priority_empty(self.active_queue)
      {
        while !ds_priority_empty(self.active_queue)
        {
          var self.scr = ds_priority_find_min(self.active_queue);
          var self.delete = script_execute(self.scr)
          //in the scripts handle combos, conflictions, and return true when finished and ready to be deleted from queue
          
          if self.delete
          {
            //show_debug_message("self.delete = true")
            ds_priority_delete_min(self.active_queue)
          } else {
            break;
          }
          if ds_priority_empty(self.active_queue)
          {
            //ds_priority_destroy(active_queue)
            self.player_state = e_player_state.attack
            self.mod_charge_timer = 0
            //show_debug_message("charged")
          }
        }
        
      } else {  //if the list is empty just spawn the weapon
        //show_debug_message("second destroy")
        ds_priority_destroy(self.active_queue)
        self.active_queue = -1
        self.player_state = e_player_state.attack
        
        
      }
      }
    }
    
    
    if ds_exists(self.active_queue, ds_type_priority)
    {
      if ds_priority_empty(self.active_queue)
      {
        //show_debug_message("third destroy")
        ds_priority_destroy(self.active_queue)
        self.active_queue = -1
      }
    }
    
    
  } else { ///if the button was released destroy the lists
    if (!self.item_a &amp;&amp; !self.item_b &amp;&amp; !self.item_c)
    {
      if ds_exists(self.active_queue, ds_type_priority)
      {
        //show_debug_message("forth destroy")
        ds_priority_destroy(self.weapon_event_queues)
        ds_priority_destroy(self.active_queue)
        self.weapon_event_queues = -1
        self.active_queue = -1
        
        self.repeater_in_queue = false
        //destroy previous weapons
        if ds_exists(self.weap_queue, ds_type_queue){
          while !ds_queue_empty(self.weap_queue){
            var weap_inst = ds_queue_dequeue(self.weap_queue)
            if instance_exists(weap_inst) &amp;&amp; (weap_inst != -1){
              if (weap_inst.object_index = obj_weapon) {
                ds_priority_destroy(weap_inst.weapon_event_queues)
                weap_inst.weapon_event_queues = -1
              
                instance_destroy(weap_inst)
              }
                weap_inst = -1
            }
          }
        }
        
      }
      //show_debug_message("the button was released")
      self.item_used_check = -1
      
      self.mod_charge_timer = 0
    }
  }
}






</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///[Modifier] Pre Weapon Queue
////////////////////////////////////////////////////////////////////
//Pre Weapon Queue
////////////////////////////////////////////////////////////////////
if self.player_state = e_player_state.attack &amp;&amp; !self.attack &amp;&amp; !self.post_attack  //if attacking but not actually the attack
{
  //show_debug_message("pre weap")
  
  //Adjust direction for more responsive controls
  if (abs(angle_difference(direction, move_dir)) &gt;= 45){
    if not ((!ceil(right) &amp;&amp; !ceil(left) &amp;&amp; !ceil(down) &amp;&amp; !ceil(up)) || 
    (right == left &amp;&amp; up == down)){
      direction = move_dir
      dir = move_dir
    }
  }
  
  var self.result = scr_run_modifiers() //pre weapon spawn modifiers
  if self.result = true {
    self.item_used_check = self.weap_num
    
    self.attack = true
    
    var weap_inst = scr_spawn_weapon(self.weap_num)
    
    //create the weapon queue and store the new weapon in it
    
    recent_weap_queue = ds_queue_create()
    ds_queue_enqueue(recent_weap_queue, weap_inst)
    
    self.weap_queue = ds_queue_create()
    ds_queue_copy(weap_queue, recent_weap_queue)
    
    
  }
}






</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///[Modifier] Post Attack Queue
////////////////////////////////////////////////////////////////////
//Post Attack Queue
////////////////////////////////////////////////////////////////////

//if finished attacking
if self.player_state = e_player_state.attack &amp;&amp; !self.attack &amp;&amp; self.post_attack
{
  //show_debug_message("Post Attack")
  
  var self.result = scr_run_modifiers()  //post attack modifiers
  if self.result = true
  {
    self.attack = false
    self.post_attack = false
    self.player_state = e_player_state.move
    
    //destroy previous weapons
    if ds_exists(self.weap_queue, ds_type_queue){
      while !ds_queue_empty(self.weap_queue){
        var weap_inst = ds_queue_dequeue(self.weap_queue)
        if instance_exists(weap_inst) &amp;&amp; (weap_inst != -1){
          if (weap_inst.object_index = obj_weapon) {
            ds_priority_destroy(weap_inst.weapon_event_queues)
            weap_inst.weapon_event_queues = -1
            
            //show_debug_message("destroyed weapon with post attack queue")
            instance_destroy(weap_inst)
          }
            weap_inst = -1
        }
      }
    }
    ds_queue_destroy(self.weap_queue)
    self.weap_queue = -1
    
      
    self.cooldown_array[1, self.weap_num] = floor(self.active_w_cooldown)
    if (self.cooldown_array[1, self.weap_num] &gt;= 1) {self.cooldown_array[0, self.weap_num] = false}
  }
  
}




</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///[Modifier] Weapon Spawn Queue
////////////////////////////////////////////////////////////////////
//Weapon Spawn Queue
////////////////////////////////////////////////////////////////////
if self.player_state = e_player_state.attack &amp;&amp; (self.attack == true) &amp;&amp; !self.post_attack//if attacking and spawning the attack
{
  //show_debug_message("Weapon Spawn")
  
  var self.result = scr_run_modifiers()  //weapon spawn mods //like enlarging the sprite and what not
    
  if self.result = true
  {
    //ds_queue_copy(weap_queue, recent_weap_queue)
    
    var queue_proj_spawn_mods = ds_priority_delete_min(self.weapon_event_queues)
    var queue_attack_step_mods = ds_priority_delete_min(self.weapon_event_queues)
    var queue_pre_col_mods = ds_priority_delete_min(self.weapon_event_queues)
    var queue_col_mods = ds_priority_delete_min(self.weapon_event_queues)
    
    while !ds_queue_empty(self.recent_weap_queue){
        var weap_inst = ds_queue_dequeue(self.recent_weap_queue);
        weap_inst.weapon_event_queues = ds_priority_create()
        
        ds_priority_add(weap_inst.weapon_event_queues, queue_proj_spawn_mods, 1) //projectile spawn mods
        ds_priority_add(weap_inst.weapon_event_queues, queue_attack_step_mods, 2) //attack step event mods
        ds_priority_add(weap_inst.weapon_event_queues, queue_pre_col_mods, 3) //pre collision Mods
        ds_priority_add(weap_inst.weapon_event_queues, queue_col_mods, 4) //collision mods
        
        weap_inst.owner_id = self.id
        weap_inst.w_start_dir = weap_inst.direction
        
    }
    ds_queue_destroy(recent_weap_queue)
    recent_weap_queue = -1
    
    self.attack = true
    self.post_attack = true
  }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="16">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if mouse_check_button(mb_left){
  test_array = encode_equipment()
}
if mouse_check_button(mb_right){
  decode_equipment(test_array)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>show_debug_player(0, "instance_number(obj_weap_proj) = "+string(instance_number(obj_weap_proj)))
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(variable_global_exists("htme_object"))
{
  if (htme_isLocal())
  {
    //htme_clientDisconnect()
    //instance_destroy(self)
    
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw self and name
//scr_view_visble_handler()

if (visible = true)
{
  
  // draw name
  if (view_object[view_current] != id){
    view_res = view_hview[view_current]/view_hport[view_current]
    draw_set_halign(fa_center);
    draw_set_valign(fa_bottom);
    sting_offset = (string_height(player_name)*view_res) + (2*view_res)
    shader_set_outline(5, c_blue)
    draw_text_transformed(x, bbox_top, player_name, view_res*obj_camera_control.upscale_val, view_res*obj_camera_control.upscale_val, 0)
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
  }
  
  
  
  //every third iframe dont draw the player
  if (ceil(iframes) mod 2) exit;
  
  
  
  //damage
  if (self.player_anim_state = e_player_anim.dmg) {
    ///if anim_damage(INCOMING DAMAGE DIRECTION){
    ///  self.player_anim_state = e_player_anim.idle
    ///}
  }else{
  
  //rotate
    if (self.player_anim_state = e_player_anim.rot) {
      if anim_rotate(){
        anim_rot_active = false
        image_xscale = -image_xscale
        //x = x - (2*image_xscale)
        self.player_anim_state = e_player_anim.idle
      }
    }else{ //if not rotating
    
  //walk
      if (self.player_anim_state = e_player_anim.walk) {
        if anim_walk(dir){
          self.player_anim_state = e_player_anim.idle
        }
      }else{
      
  //idle
        if (self.player_anim_state = e_player_anim.idle) {
          anim_idle(dir)
        }//end idle
        
      } // end !walk
      
    }// end !rotate
    
  }/// end !damage
  
  
  
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
